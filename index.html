<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Chess Defense: Masterpiece</title>
    <style>
        /* --- ëª¨ë°”ì¼ ìµœì í™” ë° ê¸°ë³¸ ì„¤ì • --- */
        body {
            background-color: #121212;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none; /* í„°ì¹˜ ì œìŠ¤ì²˜ ë°©ì§€ */
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ ëŒ€ì‘ */
            user-select: none; /* í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
        }

        /* --- ìƒë‹¨ ì •ë³´ì°½ (HUD) --- */
        #top-hud {
            height: 50px;
            background: #1e1e1e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 20;
            position: relative;
        }

        .hud-item {
            font-size: 15px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .energy-count { color: #ffd700; font-size: 18px; }
        .score-display { color: #fff; font-size: 13px; margin-left: 5px; }
        .life-display { color: #ff4444; font-size: 16px; margin-left: 8px; display: flex; align-items: center; gap: 2px; }
        .wave-text { color: #00e5ff; font-size: 16px; margin-left: 5px; text-shadow: 0 0 5px #00e5ff;}
        
        .progress-bar-bg { width: 50px; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-left: 8px; }
        .progress-bar-fill { height: 100%; background: #ff4444; width: 0%; transition: width 0.3s; }

        /* --- ê²Œì„ í™”ë©´ (Canvas) --- */
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2a2a2a;
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-bottom: 90px; /* í•˜ë‹¨ ë²„íŠ¼ ê³µê°„ í™•ë³´ */
            box-sizing: border-box;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 900/500; /* ë¹„ìœ¨ ìœ ì§€ */
        }

        /* --- íŒì—… UI ê³µí†µ ìŠ¤íƒ€ì¼ --- */
        .overlay-base {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 60;
        }

        /* 1. ì¹´ë“œ ì„ íƒ UI */
        #card-selection h2 { color: #ffd700; margin-bottom: 10px; font-size: 6vw; text-shadow: 0 0 10px #ffd700; }
        .cards-container {
            display: flex;
            justify-content: center;
            gap: 2%;
            width: 96%;
            height: 55%;
        }
        .card {
            background: linear-gradient(145deg, #2a2a2a, #333);
            border: 2px solid #555;
            border-radius: 12px;
            width: 32%;
            height: 100%;
            padding: 8px 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.1s;
            box-sizing: border-box;
        }
        .card:active { transform: scale(0.95); border-color: #ffd700; background: #3a3a3a; }
        
        .card-icon { font-size: 8vw; margin: 5px 0; }
        .card-title { font-weight: bold; color: #fff; margin-bottom: 5px; font-size: 3.2vw; white-space: nowrap; }
        .card-desc { font-size: 2.5vw; color: #ccc; line-height: 1.3; padding: 0 2px; word-break: keep-all; flex: 1; display: flex; align-items: center; justify-content: center; }
        .card-rare { color: #ffd700; font-size: 2.5vw; margin: 5px 0; border: 1px solid #ffd700; padding: 2px 6px; border-radius: 10px;}

        /* ë¦¬ë¡¤ ë²„íŠ¼ */
        .reroll-btn {
            margin-top: 15px;
            padding: 10px 25px;
            background: #444;
            border: 1px solid #fff;
            color: #fff;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }
        .reroll-btn:active { background: #666; }

        /* 2. ìœ ë‹› ì—…ê·¸ë ˆì´ë“œ íŒ¨ë„ */
        #upgrade-panel {
            position: absolute;
            bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700; border-radius: 15px;
            padding: 15px;
            display: none;
            flex-direction: column; align-items: center;
            z-index: 50; width: 65%; max-width: 300px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        .action-btn { padding: 12px; border:none; border-radius:8px; width:100%; margin-top:6px; font-weight:bold; cursor:pointer; font-size: 14px;}
        .btn-upgrade { background:#ffd700; color:#000; }
        .btn-alt { background:#00e5ff; color:#000; }
        .btn-sell { background: #e74c3c; color: white; }
        .btn-close { background:#444; color:#fff; }

        /* 3. ì›¨ì´ë¸Œ ì•Œë¦¼ ëª¨ë‹¬ */
        #wave-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid #00e5ff;
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            z-index: 80;
            display: none;
            width: 80%; max-width: 350px;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.3);
            animation: fadeIn 0.3s;
        }
        #wave-modal h2 { margin: 0 0 10px 0; color: #00e5ff; font-size: 24px; }
        .wave-info-row { display: flex; justify-content: space-between; margin: 8px 0; font-size: 16px; border-bottom: 1px solid #444; padding-bottom: 4px;}
        .wave-info-val { color: #ffd700; font-weight: bold; }
        
        .new-enemy-alert { background: #331111; border: 1px solid #ff4444; padding: 10px; border-radius: 8px; margin-top: 15px; }
        .new-enemy-title { color: #ff4444; font-weight: bold; font-size: 16px; display: block; margin-bottom: 5px;}
        .new-enemy-desc { font-size: 13px; color: #ccc; word-break: keep-all; line-height: 1.4; }

        /* 4. ê²Œì„ ì˜¤ë²„ / ë©”ì¸ í™”ë©´ */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }
        .big-btn { padding: 15px 40px; font-size: 22px; background: #ffd700; border: none; border-radius: 30px; font-weight: bold; cursor: pointer; margin-top: 20px; }
        
        #rank-info {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 15px;
            width: 80%; max-width: 300px;
            border: 1px solid #555;
        }
        .rank-stat { font-size: 16px; color: #ccc; margin: 5px 0; }
        .rank-val { color: #ffd700; font-weight: bold; font-size: 20px; }
        
        #new-record-form { display: none; margin-top: 15px; text-align: center; animation: popIn 0.5s ease; }
        #player-name-input { padding: 10px; font-size: 16px; border-radius: 5px; border: none; width: 70%; margin-bottom: 10px; text-align: center; }
        .submit-btn { background: #00e5ff; color: #000; padding: 10px 20px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; }

        /* í•˜ë‹¨ ìœ ë‹› ì„ íƒ ë°” (ê³ ì •) */
        #bottom-bar {
            height: 90px;
            background: #1e1e1e;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
            border-top: 2px solid #333;
            z-index: 20;
            position: fixed;
            bottom: 0; left: 0; width: 100%;
            box-sizing: border-box;
            padding-bottom: env(safe-area-inset-bottom);
        }
        .unit-btn {
            background: #333; border: 2px solid #444; border-radius: 8px;
            width: 15%; height: 90%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; position: relative;
        }
        .unit-btn.selected { border-color: #ffd700; background: #4a4a3a; }
        .unit-btn.disabled { opacity: 0.4; filter: grayscale(100%); }
        .unit-cost { font-size: 10px; color: #ffd700; font-weight: bold; margin-top: 2px;}

        /* PC í™”ë©´ ëŒ€ì‘ */
        @media (min-width: 600px) {
            #card-selection h2 { font-size: 30px; }
            #card-selection p { font-size: 16px; }
            .card-icon { font-size: 40px; }
            .card-title { font-size: 16px; }
            .card-desc { font-size: 13px; }
            .card-rare { font-size: 12px; }
            .cards-container { width: 80%; height: 50%; gap: 20px;}
            .card { width: 150px; height: 220px; }
        }
        
        @keyframes popIn { from {transform: scale(0.5); opacity: 0;} to {transform: scale(1); opacity: 1;} }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -60%); } to { opacity: 1; transform: translate(-50%, -50%); } }

    </style>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, serverTimestamp, updateDoc, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ğŸ”¥ Firebase ì„¤ì •
        const firebaseConfig = {
            apiKey: "AIzaSyAQc4zmexSGF19tSTJs6pTgtFOE0z--6XA",
            authDomain: "game-28340361-cd827.firebaseapp.com",
            projectId: "game-28340361-cd827",
            storageBucket: "game-28340361-cd827.firebasestorage.app",
            messagingSenderId: "642880657235",
            appId: "1:642880657235:web:b0b00984a8b5590f1bb3a6"
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            signInAnonymously(auth).catch(e => console.error("Auth Fail:", e));
        } catch(e) {
            console.error("Firebase Init Error:", e);
        }

        let currentUser = null;
        const authReady = new Promise((resolve) => {
            if(!auth) return resolve(null);
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    resolve(user);
                }
            });
        });

        // ğŸ”¥ ë­í‚¹ ë¡œì§: 50ìœ„ ì´ë‚´ ì €ì¥
        window.saveScoreAndCheckRank = async (finalScore) => {
            if (!db) return { rank: 'ì„¤ì • ì˜¤ë¥˜', nextScore: '-', nextRankInfo: '', isNewRecord: false };

            try {
                await authReady;
                const uid = auth.currentUser ? auth.currentUser.uid : 'guest';
                const colRef = collection(db, 'scores');

                const snapshot = await getDocs(colRef);
                let allScores = [];
                snapshot.forEach(d => allScores.push({ ...d.data(), id: d.id }));
                
                const tempMe = { score: finalScore, name: "Unknown", id: "temp_me" };
                allScores.push(tempMe);
                // ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (ë†’ì€ ì ìˆ˜ê°€ 1ë“±)
                allScores.sort((a, b) => b.score - a.score);

                const myIndex = allScores.findIndex(s => s.id === "temp_me");
                const myRank = myIndex + 1;
                
                let nextScore = '-';
                let nextRankInfo = 'ìµœê³  ê¸°ë¡!';

                if (myRank === 1) {
                    nextScore = 'New Best!';
                    nextRankInfo = '1ìœ„ ë‹¬ì„±';
                } else {
                    const prevPlayer = allScores[myIndex - 1];
                    if (prevPlayer) {
                        nextScore = prevPlayer.score;
                        nextRankInfo = `${myRank - 1}ìœ„ ì ìˆ˜`;
                    }
                }
                
                if (myRank > 50) {
                    const cutPlayer = allScores[49]; // 50ë“±
                    if (cutPlayer) {
                        nextScore = cutPlayer.score;
                        nextRankInfo = '50ìœ„ ì»¤íŠ¸ë¼ì¸';
                    }
                }

                let savedDocId = null;
                let isNewRecord = (myRank === 1);

                if (myRank <= 50) {
                    const docRef = await addDoc(colRef, {
                        score: finalScore,
                        name: "Unknown",
                        ts: serverTimestamp(),
                        uid: uid
                    });
                    savedDocId = docRef.id;
                }

                return {
                    rank: myRank > 50 ? "50ìœ„ ë°–" : myRank,
                    topScore: allScores[0].score,
                    topName: allScores[0].name,
                    nextScore: nextScore,
                    nextRankInfo: nextRankInfo,
                    isNewRecord: isNewRecord && (myRank <= 50),
                    docId: savedDocId
                };

            } catch (e) {
                console.error("Ranking System Error:", e);
                return { rank: 'Error', nextScore: '-', isNewRecord: false };
            }
        };

        window.updatePlayerName = async (docId, newName) => {
            if (!db || !docId) return;
            try {
                const docRef = doc(db, 'scores', docId);
                await updateDoc(docRef, { name: newName });
                return true;
            } catch(e) {
                console.error("Name Update Error:", e);
                return false;
            }
        };

        window.submitName = () => {
            const nameInput = document.getElementById('player-name-input');
            const name = nameInput.value.trim();
            if (!name || name.length > 8) {
                alert("ì´ë¦„ì„ 1~8ê¸€ìë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                return;
            }
            if (window.currentDocId && window.updatePlayerName) {
                window.updatePlayerName(window.currentDocId, name).then(() => {
                    const elName = document.getElementById('res-top-name');
                    if(elName) elName.innerText = name;
                    document.getElementById('new-record-form').innerHTML = "<h4 style='color:#00e5ff'>ì´ë¦„ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!</h4>";
                });
            }
        };
    </script>
</head>
<body>

    <div id="top-hud">
        <div class="hud-item">
            <span>âš¡</span><span class="energy-count" id="ui-energy">150</span>
            <span class="score-display">(ì ìˆ˜: <span id="ui-score">0</span>)</span>
            <span class="life-display">â¤ï¸ <span id="ui-lives">3</span></span>
        </div>
        <div class="hud-item">
            <span class="wave-text" id="ui-wave">Wave 1</span>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="wave-progress"></div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="wave-modal">
            <h2 id="wave-modal-title">Wave 1</h2>
            <div class="wave-info-row">
                <span>ì´ì íšë“</span>
                <span class="wave-info-val" id="wave-interest">+0 G</span>
            </div>
            <div class="wave-info-row">
                <span>í˜„ì¬ ìì›</span>
                <span class="wave-info-val" id="wave-total-gold">150 G</span>
            </div>
            <div id="new-enemy-alert" class="new-enemy-alert" style="display:none;">
                <span class="new-enemy-title">âš ï¸ ìƒˆë¡œìš´ ì  ì¶œí˜„!</span>
                <span id="new-enemy-desc" class="new-enemy-desc">ì„¤ëª…</span>
            </div>
        </div>

        <div id="card-selection" class="overlay-base">
            <h2>ğŸ‰ Wave Clear!</h2>
            <p>ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”</p>
            <div class="cards-container" id="cards-box"></div>
            <button class="reroll-btn" id="btn-reroll" onclick="rerollCards()">
                ğŸ² ì¹´ë“œ ë‹¤ì‹œ ë½‘ê¸° (ë¬´ë£Œ)
            </button>
        </div>

        <div id="upgrade-panel">
            <div id="upgrade-info" style="font-weight:bold; font-size:18px; color:#ffd700; margin-bottom:5px;">Lv.1 í°</div>
            <div id="upgrade-stats" style="color:#ccc; font-size:12px; margin-bottom:5px;">ìŠ¤íƒ¯ ì •ë³´</div>
            
            <button class="action-btn btn-upgrade" id="btn-do-upgrade">ê°•í™”</button>
            <button class="action-btn btn-alt" id="btn-alt-upgrade" style="display:none;">ê´‘í­í™”</button>
            <button class="action-btn btn-sell" id="btn-do-sell" onclick="sellSelectedUnit()">íŒë§¤</button>
            <button class="action-btn btn-close" onclick="closeUpgradePanel()">ë‹«ê¸°</button>
        </div>

        <div id="overlay">
            <h1 style="color:#ffd700; margin-bottom:10px; font-size:32px;">ğŸƒ Chess Defense</h1>
            <p id="overlay-msg" style="color:#ccc; text-align:center; margin-bottom:20px; line-height:1.5;">
                ë°©ì–´ì„ ì„ êµ¬ì¶•í•˜ê³  ì›¨ì´ë¸Œë¥¼ ë§‰ì•„ë‚´ì„¸ìš”.<br>
                50ìœ„ ì•ˆì— ë“¤ë©´ ëª…ì˜ˆì˜ ì „ë‹¹ì— ì˜¤ë¦…ë‹ˆë‹¤.
            </p>
            <div id="rank-info" style="display:none;">
                <div class="rank-stat">ë‚´ ì ìˆ˜</div>
                <div class="rank-val" id="res-score">0</div>
                <hr style="border-color:#444; margin:10px 0;">
                <div class="rank-stat">ë‚´ ìˆœìœ„</div>
                <div class="rank-val" id="res-rank" style="color:#00e5ff;">ê³„ì‚° ì¤‘...</div>
                
                <div class="rank-stat" style="font-size:14px; margin-top:15px; color:#aaa;">
                    ğŸ¯ <span id="res-next-rank">ëª©í‘œ</span> : 
                    <span id="res-next-score" style="color:#fff;">-</span>
                </div>

                <div class="rank-stat" style="font-size:14px; margin-top:10px; color:#ffd700;">
                    ğŸ† ì „ì²´ 1ë“±: <span id="res-top-name">Unknown</span> (<span id="res-top-score">-</span>)
                </div>

                <div id="new-record-form">
                    <h3 style="color:#ffd700; margin:10px 0;">ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! 1ë“±ì…ë‹ˆë‹¤! ğŸ‰</h3>
                    <input type="text" id="player-name-input" placeholder="ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ìµœëŒ€ 8ì)" maxlength="8">
                    <button class="submit-btn" onclick="submitName()">ê¸°ë¡ ë‚¨ê¸°ê¸°</button>
                </div>
            </div>
            <button class="big-btn" id="start-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <div id="bottom-bar">
        <div class="unit-btn" id="btn-king" onclick="selectUnitType('king')">
            <div class="unit-icon" style="font-size:24px">â™š</div>
            <div class="unit-cost">100</div>
            <div style="font-size:9px; color:#ccc">í‚¹(ìì›)</div>
        </div>
        <div class="unit-btn" id="btn-pawn" onclick="selectUnitType('pawn')">
            <div class="unit-icon" style="font-size:24px">â™Ÿï¸</div>
            <div class="unit-cost">50</div>
            <div style="font-size:9px; color:#ccc">í°(ë°©íŒ¨)</div>
        </div>
        <div class="unit-btn" id="btn-rook" onclick="selectUnitType('rook')">
            <div class="unit-icon" style="font-size:24px">â™œ</div>
            <div class="unit-cost">370</div>
            <div style="font-size:9px; color:#ccc">ë£©(ì§ì„ )</div>
        </div>
        <div class="unit-btn" id="btn-bishop" onclick="selectUnitType('bishop')">
            <div class="unit-icon" style="font-size:24px">â™</div>
            <div class="unit-cost">120</div>
            <div style="font-size:9px; color:#ccc">ë¹„ìˆ(ëŒ€ê°)</div>
        </div>
        <div class="unit-btn" id="btn-knight" onclick="selectUnitType('knight')">
            <div class="unit-icon" style="font-size:24px">â™</div>
            <div class="unit-cost">500</div>
            <div style="font-size:9px; color:#ccc">ë‚˜ì´íŠ¸(ë²”ìœ„)</div>
        </div>
        <div class="unit-btn" id="btn-queen" onclick="selectUnitType('queen')">
            <div class="unit-icon" style="font-size:24px">â™›</div>
            <div class="unit-cost">1500</div>
            <div style="font-size:9px; color:#ccc">í€¸(ë©€í‹°)</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GAME_WIDTH = 900;
    const GAME_HEIGHT = 500;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    const CELL_SIZE = 100;
    const COLS = 9;
    const ROWS = 5;

    let isPlaying = false;
    let isPaused = false;
    let isWaveStarting = false;
    let energy = 150;
    let score = 0; 
    let lives = 3; 
    let frame = 0;
    
    let wave = 1;
    let enemiesToSpawn = 0;
    let enemiesSpawned = 0;
    let enemiesKilled = 0;
    let waveTotalEnemies = 0;

    let currentRerollCost = 0;

    let globalBuffs = { 
        dmgMult: 1.0, spdMult: 1.0, costMult: 1.0, hpMult: 1.0, kingGold: 0,
        enemySpeedMult: 1.0, goldPerKill: 0, rangeMult: 1.0, critChance: 0, sellRefund: 0.5,
        pawnLoot: false
    };

    let selectedType = null;
    let focusedUnit = null;

    let defenders = [];
    let enemies = [];
    let projectiles = [];
    let particles = [];
    let floatingTexts = [];

    window.currentDocId = null;

    const UNITS = {
        'king':   { cost: 100,  hp: 200, dmg: 0.2, spd: 120, upCost: 120, color: '#ffd700', icon: 'â™š', name: 'í‚¹' },
        'pawn':   { cost: 50,  hp: 400, dmg: 10,  spd: 60,  upCost: 30,  color: '#aaa',    icon: 'â™Ÿï¸', name: 'í°' },
        'rook':   { cost: 370, hp: 200, dmg: 30,  spd: 90,  upCost: 120, color: '#4a90e2', icon: 'â™œ', name: 'ë£©' },
        'bishop': { cost: 120, hp: 150, dmg: 40,  spd: 60,  upCost: 40,  color: '#9013fe', icon: 'â™', name: 'ë¹„ìˆ' },
        'knight': { cost: 500, hp: 300, dmg: 18,  spd: 120, upCost: 200, color: '#7ed321', icon: 'â™', name: 'ë‚˜ì´íŠ¸' },
        'queen':  { cost: 1500, hp: 500, dmg: 25,  spd: 45,  upCost: 300, color: '#ff00ff', icon: 'â™›', name: 'í€¸' }
    };

    const CARD_POOL = [
        { id: 'atk_up',   icon: 'âš”ï¸', title: 'ì „êµ° ëŒê²©', desc: 'ì•„êµ° ê³µê²©ë ¥ +20%' },
        { id: 'spd_up',   icon: 'âš¡', title: 'ê´‘ì† ëª¨ë“œ', desc: 'ì•„êµ° ê³µì† +15%' },
        { id: 'hp_up',    icon: 'ğŸ›¡ï¸', title: 'ê°•ì²  ê°‘ì˜·', desc: 'ì•„êµ° ì²´ë ¥ +25%' },
        { id: 'cost_dn',  icon: 'ğŸ’°', title: 'ìì› ì ˆì•½', desc: 'ë°°ì¹˜ ë¹„ìš© -10%' },
        { id: 'king_up',  icon: 'ğŸ‘‘', title: 'ì™•ì˜ ì„¸ê¸ˆ', desc: 'í‚¹ ìì›ìƒì‚° +0.2' },
        { id: 'rich',     icon: 'ğŸ’', title: 'ë³´ê¸‰í’ˆ',    desc: 'ì¦‰ì‹œ ìì› +200' },
        { id: 'heal_all', icon: 'ğŸ’Š', title: 'ê¸´ê¸‰ ìˆ˜ë¦¬', desc: 'ëª¨ë“  ì•„êµ° ì²´ë ¥ 100% íšŒë³µ' },
        { id: 'slow',     icon: 'â„ï¸', title: 'ì–¼ìŒ ì§€ëŒ€', desc: 'ì  ì´ë™ì†ë„ -10%' },
        { id: 'bounty',   icon: 'ğŸ’°', title: 'í˜„ìƒê¸ˆ',    desc: 'ì  ì²˜ì¹˜ ì‹œ +3ê³¨ë“œ' },
        { id: 'range',    icon: 'ğŸ”­', title: 'ì €ê²© í›ˆë ¨', desc: 'í°/ë‚˜ì´íŠ¸ ì‚¬ê±°ë¦¬ +20%' },
        { id: 'crit',     icon: 'âš¡', title: 'ì¹˜ëª…íƒ€',    desc: '10% í™•ë¥ ë¡œ 2ë°° ë°ë¯¸ì§€' },
        { id: 'recycle',  icon: 'â™»ï¸', title: 'ì¬í™œìš©',    desc: 'íŒë§¤ í™˜ê¸‰ë¥  80%ë¡œ ì¦ê°€' },
        { id: 'life_up',  icon: 'â¤ï¸', title: 'ëª©ìˆ¨+1!!',  desc: 'ê¸°ì§€ ìƒëª…ë ¥ +1' },
        { id: 'pawn_loot', icon: 'ğŸ´â€â˜ ï¸', title: 'ì•½íƒˆì', desc: 'í°ì´ í‚¬í•  ë•Œë§ˆë‹¤ +1 ìì›' }
    ];

    const ENEMY_TYPES = [
        { minWave: 1,  type: 'normal', name: 'ë³‘ì‚¬', desc: 'í‰ë²”í•œ ì ì…ë‹ˆë‹¤.', color: '#e74c3c', hpMult: 1.0, spdMult: 1.0, radius: 35, ability: null },
        { minWave: 3,  type: 'bomber', name: 'ìí­ë³‘', desc: 'ì£½ì„ ë•Œ ì£¼ë³€ì— í° í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.', color: '#ff6600', hpMult: 0.8, spdMult: 1.3, radius: 30, ability: 'explode' }, 
        { minWave: 5,  type: 'fast',   name: 'ì •ì°°ë³‘', desc: 'ë¹ ë¥´ê³  íšŒí”¼ ëŠ¥ë ¥ì´ ìˆìŠµë‹ˆë‹¤.', color: '#f1c40f', hpMult: 0.6, spdMult: 1.5, radius: 25, ability: 'dodge' },
        { minWave: 10, type: 'tank',   name: 'ê±°ì¸',   desc: 'ì²´ë ¥ì´ ë†’ê³  ë°ë¯¸ì§€ë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤.', color: '#8e44ad', hpMult: 2.5, spdMult: 0.6, radius: 45, ability: 'armor' },
        { minWave: 15, type: 'boss',   name: 'ì¥êµ°',   desc: 'ë¶€í•˜ë¥¼ ì†Œí™˜í•˜ë©° ì•„êµ°ì„ ê¸°ì ˆì‹œí‚µë‹ˆë‹¤.', color: '#2c3e50', hpMult: 5.0, spdMult: 0.4, radius: 50, ability: 'stun' }
    ];

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('rank-info').style.display = 'none'; 
        document.getElementById('new-record-form').style.display = 'none';
        initGame();
        startWave(1);
        animate();
    }

    function initGame() {
        defenders = []; enemies = []; projectiles = []; particles = []; floatingTexts = [];
        energy = 150; score = 0; lives = 3; 
        frame = 0; isPlaying = true; isPaused = false; isWaveStarting = false;
        globalBuffs = { 
            dmgMult: 1.0, spdMult: 1.0, costMult: 1.0, hpMult: 1.0, kingGold: 0,
            enemySpeedMult: 1.0, goldPerKill: 0, rangeMult: 1.0, critChance: 0, sellRefund: 0.5,
            pawnLoot: false
        };
        closeUpgradePanel();
        updateUI();
    }

    function startWave(waveNum) {
        wave = waveNum; enemiesSpawned = 0; enemiesKilled = 0;
        currentRerollCost = 0;
        isWaveStarting = true; 

        const interest = wave > 1 ? Math.round(energy * 0.1 * 10) / 10 : 0;
        if (interest > 0) {
            energy += interest;
            score += interest;
        }

        waveTotalEnemies = 1 + (wave - 1) * 3; 
        
        let isHorde = Math.random() < 0.05;
        if (isHorde) {
            waveTotalEnemies *= 2;
            spawnFloatingText("âš ï¸ ëŒ€ê·œëª¨ ì›¨ì´ë¸Œ! âš ï¸", GAME_WIDTH/2, GAME_HEIGHT/2, '#ff0000', 30);
        } else {
            spawnFloatingText(`Wave ${wave} Start!`, GAME_WIDTH/2, GAME_HEIGHT/2, '#00e5ff');
        }

        enemiesToSpawn = waveTotalEnemies;
        
        const modal = document.getElementById('wave-modal');
        document.getElementById('wave-modal-title').innerText = `Wave ${wave}`;
        document.getElementById('wave-interest').innerText = `+${interest} G`;
        document.getElementById('wave-total-gold').innerText = `${Math.floor(energy)} G`;

        const newEnemy = ENEMY_TYPES.find(e => e.minWave === wave);
        const alertBox = document.getElementById('new-enemy-alert');
        if (newEnemy) {
            alertBox.style.display = 'block';
            alertBox.innerHTML = `
                <span class="new-enemy-title" style="color:${newEnemy.color}">âš ï¸ ìƒˆë¡œìš´ ì  ì¶œí˜„! ${newEnemy.name}</span>
                <span class="new-enemy-desc">${newEnemy.desc}</span>
            `;
        } else {
            alertBox.style.display = 'none';
        }

        modal.style.display = 'block';
        updateUI();

        setTimeout(() => {
            modal.style.display = 'none';
            isWaveStarting = false;
            updateUI(); 
        }, 4000);
    }

    function checkWaveClear() {
        if (enemiesKilled >= waveTotalEnemies) {
             showCardSelection();
        }
    }

    function showCardSelection() {
        isPaused = true;
        const cardBox = document.getElementById('cards-box');
        cardBox.innerHTML = ''; 
        const shuffled = [...CARD_POOL].sort(() => 0.5 - Math.random());
        const picks = shuffled.slice(0, 3);

        picks.forEach(card => {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `
                <div class="card-icon">${card.icon}</div>
                <div class="card-title">${card.title}</div>
                <div class="card-desc">${card.desc}</div>
                <div class="card-rare">ì„ íƒ</div>
            `;
            el.onclick = () => selectCard(card.id);
            cardBox.appendChild(el);
        });

        const rerollBtn = document.getElementById('btn-reroll');
        if (!rerollBtn) { 
             const btn = document.createElement('button');
             btn.id = 'btn-reroll';
             btn.className = 'reroll-btn';
             btn.onclick = rerollCards;
             document.getElementById('card-selection').appendChild(btn);
        }
        updateRerollButton();
        
        document.getElementById('card-selection').style.display = 'flex';
    }

    window.rerollCards = () => {
        if (energy < currentRerollCost) {
            alert("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!");
            return;
        }
        energy -= currentRerollCost;
        currentRerollCost = 10; 
        updateUI();
        showCardSelection();
    };

    function updateRerollButton() {
        const btn = document.getElementById('btn-reroll');
        if (btn) {
            btn.innerText = currentRerollCost === 0 ? "ğŸ² ë¦¬ë¡¤ (ë¬´ë£Œ)" : `ğŸ² ë¦¬ë¡¤ (${currentRerollCost}G)`;
            btn.style.opacity = (energy < currentRerollCost) ? 0.5 : 1.0;
        }
    }

    function selectCard(cardId) {
        switch(cardId) {
            case 'atk_up': globalBuffs.dmgMult += 0.2; break;
            case 'spd_up': globalBuffs.spdMult += 0.15; break;
            case 'hp_up':  globalBuffs.hpMult += 0.25; break;
            case 'cost_dn': globalBuffs.costMult *= 0.9; break;
            case 'king_up': globalBuffs.kingGold += 0.2; break;
            case 'rich': energy += 200; score += 200; break;
            case 'heal_all': defenders.forEach(d => { d.hp = d.maxHp; spawnFloatingText("Heal!", d.x+50, d.y, '#00ff00'); }); break;
            case 'slow': globalBuffs.enemySpeedMult *= 0.9; break;
            case 'bounty': globalBuffs.goldPerKill += 3; break;
            case 'range': globalBuffs.rangeMult += 0.2; break;
            case 'crit': globalBuffs.critChance += 0.1; break;
            case 'recycle': globalBuffs.sellRefund = 0.8; break;
            case 'life_up': lives++; spawnFloatingText("ëª©ìˆ¨ +1", GAME_WIDTH/2, GAME_HEIGHT/2, '#ff4444', 30); break;
            case 'pawn_loot': globalBuffs.pawnLoot = true; break;
        }
        defenders.forEach(d => d.applyBuffs());
        document.getElementById('card-selection').style.display = 'none';
        isPaused = false;
        startWave(wave + 1);
        updateUI();
    }

    function updateUI() {
        const elEnergy = document.getElementById('ui-energy');
        const elScore = document.getElementById('ui-score');
        const elLives = document.getElementById('ui-lives');
        const elWave = document.getElementById('ui-wave');
        const elProgress = document.getElementById('wave-progress');

        if(elEnergy) elEnergy.innerText = Math.floor(energy);
        if(elScore) elScore.innerText = Math.floor(score);
        if(elLives) elLives.innerText = lives;
        if(elWave) elWave.innerText = `Wave ${wave}`;
        
        if(elProgress) {
            const progress = Math.min(100, (enemiesKilled / waveTotalEnemies) * 100);
            elProgress.style.width = `${progress}%`;
        }

        ['king', 'pawn', 'rook', 'bishop', 'knight', 'queen'].forEach(t => {
            const btn = document.getElementById(`btn-${t}`);
            if (btn) {
                const realCost = Math.floor(UNITS[t].cost * globalBuffs.costMult);
                const costDisplay = btn.querySelector('.unit-cost');
                if (costDisplay) costDisplay.innerText = realCost;
                
                if (selectedType === t) btn.classList.add('selected'); else btn.classList.remove('selected');
                if (energy < realCost) btn.classList.add('disabled'); else btn.classList.remove('disabled');
            }
        });

        if (focusedUnit) {
            const nextCost = focusedUnit.getUpgradeCost();
            const btnUp = document.getElementById('btn-do-upgrade');
            const btnAlt = document.getElementById('btn-alt-upgrade');

            if (btnUp && btnUp.style.display !== 'none') {
                btnUp.style.opacity = (energy < nextCost) ? 0.5 : 1.0;
            }
            if (btnAlt && btnAlt.style.display !== 'none') {
                btnAlt.style.opacity = (energy < nextCost) ? 0.5 : 1.0;
            }
        }
        
        updateRerollButton();
    }

    window.selectUnitType = function(type) {
        if (!isPlaying || isPaused || isWaveStarting) return;
        if (selectedType === type) selectedType = null;
        else selectedType = type;
        closeUpgradePanel();
        updateUI();
    };

    function handleInput(cx, cy) {
        if (!isPlaying || isPaused || isWaveStarting) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (cx - rect.left) * scaleX;
        const y = (cy - rect.top) * scaleY;
        const gx = Math.floor(x / CELL_SIZE) * CELL_SIZE;
        const gy = Math.floor(y / CELL_SIZE) * CELL_SIZE;

        if (gx >= GAME_WIDTH - CELL_SIZE || gx < 0 || gy < 0 || gy >= GAME_HEIGHT) {
            selectedType = null; closeUpgradePanel(); updateUI(); return;
        }

        const clickedUnit = defenders.find(d => d.x === gx && d.y === gy);

        if (clickedUnit) {
            openUpgradePanel(clickedUnit);
            selectedType = null;
        } else if (selectedType) {
            const baseCost = UNITS[selectedType].cost;
            const finalCost = Math.floor(baseCost * globalBuffs.costMult);
            if (energy >= finalCost) {
                defenders.push(new Defender(gx, gy, selectedType));
                energy -= finalCost;
                spawnParticles(gx+50, gy+50, 10, '#ffd700');
                selectedType = null; updateUI();
            }
        } else {
            closeUpgradePanel();
        }
    }

    function openUpgradePanel(unit) {
        focusedUnit = unit;
        const panel = document.getElementById('upgrade-panel');
        const nextCost = unit.getUpgradeCost();
        const sellPrice = Math.floor(UNITS[unit.type].cost * globalBuffs.sellRefund);

        document.getElementById('upgrade-info').innerText = `Lv.${unit.level} ${UNITS[unit.type].name}`;
        
        let statText = "";
        if (unit.type === 'king') {
            statText = `ìƒì‚°ëŸ‰: ${unit.damage.toFixed(1)} -> ${(unit.damage + 0.2).toFixed(1)}`;
        } else {
            statText = `ê³µê²©ë ¥: ${unit.damage} -> ${Math.floor(unit.damage * 1.3)}`;
        }
        document.getElementById('upgrade-stats').innerText = statText;
        
        const btnUp = document.getElementById('btn-do-upgrade');
        const btnAlt = document.getElementById('btn-alt-upgrade');

        // ğŸ”¥ í° ì„ íƒí˜• ì—…ê·¸ë ˆì´ë“œ UI
        if (unit.type === 'pawn') {
            if (unit.level === 1) {
                btnUp.style.display = 'block';
                btnUp.innerText = `ìˆ˜í˜¸ì (ì²´ë ¥+20%) - ${nextCost}G`;
                btnUp.onclick = () => upgradeSelectedUnit('tank');

                btnAlt.style.display = 'block';
                btnAlt.innerText = `ê´‘ì „ì‚¬ (ê³µì†+15%) - ${nextCost}G`;
                btnAlt.onclick = () => upgradeSelectedUnit('berserk');
            } else {
                btnAlt.style.display = 'none';
                if (unit.upgradePath === 'tank') {
                    btnUp.style.display = 'block';
                    btnUp.innerText = `ìˆ˜í˜¸ì ê°•í™” - ${nextCost}G`;
                    btnUp.onclick = () => upgradeSelectedUnit('tank');
                } else if (unit.upgradePath === 'berserk') {
                    btnUp.style.display = 'block';
                    btnUp.innerText = `ê´‘ì „ì‚¬ ê°•í™” - ${nextCost}G`;
                    btnUp.onclick = () => upgradeSelectedUnit('berserk');
                }
            }
        } 
        // ğŸ”¥ ë¹„ìˆ ì„ íƒí˜• ì—…ê·¸ë ˆì´ë“œ UI ì¶”ê°€
        else if (unit.type === 'bishop') {
            if (unit.level === 1) {
                btnUp.style.display = 'block';
                btnUp.innerText = `ì†ì‚¬ (ê³µì†+40% / ë€-25%) - ${nextCost}G`;
                btnUp.onclick = () => upgradeSelectedUnit('rapid');

                btnAlt.style.display = 'block';
                btnAlt.innerText = `ë§ˆë ¥ (ë€+35% / ê³µì†-25%) - ${nextCost}G`; // ìˆ˜ì¹˜ ì¡°ì • ë°˜ì˜
                btnAlt.onclick = () => upgradeSelectedUnit('power');
            } else {
                btnAlt.style.display = 'none';
                if (unit.upgradePath === 'rapid') {
                    btnUp.style.display = 'block';
                    btnUp.innerText = `ì†ì‚¬ ê°•í™” - ${nextCost}G`;
                    btnUp.onclick = () => upgradeSelectedUnit('rapid');
                } else if (unit.upgradePath === 'power') {
                    btnUp.style.display = 'block';
                    btnUp.innerText = `ë§ˆë ¥ ê°•í™” - ${nextCost}G`;
                    btnUp.onclick = () => upgradeSelectedUnit('power');
                }
            }
        }
        else {
            btnUp.style.display = 'block';
            btnUp.innerText = `ê°•í™” (${nextCost}G)`;
            btnUp.onclick = () => upgradeSelectedUnit('normal');
            btnAlt.style.display = 'none';
        }
        
        btnUp.style.opacity = (energy < nextCost) ? 0.5 : 1.0;
        if(btnAlt.style.display !== 'none') btnAlt.style.opacity = (energy < nextCost) ? 0.5 : 1.0;
        
        document.getElementById('btn-do-sell').innerText = `íŒë§¤ (+${sellPrice}G)`;
        panel.style.display = 'flex';
    }

    window.closeUpgradePanel = () => { document.getElementById('upgrade-panel').style.display = 'none'; focusedUnit = null; };
    
    // ğŸ”¥ ì—…ê·¸ë ˆì´ë“œ í•¨ìˆ˜
    window.upgradeSelectedUnit = (mode) => {
        if (!focusedUnit) return;
        const cost = focusedUnit.getUpgradeCost();
        if (energy >= cost) {
            energy -= cost;
            focusedUnit.levelUp(mode);
            spawnParticles(focusedUnit.x+50, focusedUnit.y+50, 20, '#fff');
            
            let txt = "LEVEL UP!";
            if (mode === 'berserk') txt = "BERSERK!";
            if (mode === 'tank') txt = "GUARDIAN!";
            if (mode === 'rapid') txt = "RAPID!";
            if (mode === 'power') txt = "POWER!";
            spawnFloatingText(txt, focusedUnit.x+50, focusedUnit.y);
            
            openUpgradePanel(focusedUnit); updateUI();
        }
    };

    window.sellSelectedUnit = () => {
        if (!focusedUnit) return;
        const baseCost = UNITS[focusedUnit.type].cost;
        const invest = baseCost + ((focusedUnit.level - 1) * UNITS[focusedUnit.type].upCost);
        const sellPrice = Math.floor(invest * globalBuffs.sellRefund);

        energy += sellPrice;
        spawnFloatingText(`+${sellPrice} G`, focusedUnit.x+50, focusedUnit.y, '#ffd700');
        spawnParticles(focusedUnit.x+50, focusedUnit.y+50, 15, '#888');

        defenders = defenders.filter(d => d !== focusedUnit);
        closeUpgradePanel();
        updateUI();
    };

    canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

    class Defender {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.level = 1; this.baseStats = UNITS[type];
            this.color = this.baseStats.color; this.icon = this.baseStats.icon;
            
            // ì´ˆê¸°í™”
            this.extraHpMult = 1.0; 
            this.extraSpdMult = 1.0;
            this.extraDmgMult = 1.0; 
            this.upgradePath = null; 
            this.stunTimer = 0;
            
            this.applyBuffs(); 
            this.hp = this.maxHp;
            this.timer = 0; 
        }

        applyBuffs() {
            const lvlMult = Math.pow(1.2, this.level - 1);
            
            let finalHpMult = globalBuffs.hpMult * this.extraHpMult;
            let finalSpdMult = globalBuffs.spdMult * this.extraSpdMult;
            let finalDmgMult = globalBuffs.dmgMult * this.extraDmgMult;

            this.maxHp = Math.floor(this.baseStats.hp * lvlMult * finalHpMult);
            
            if (this.type === 'king') {
                this.damage = 0.2 + ((this.level-1) * 0.2) + globalBuffs.kingGold;
            } else {
                this.damage = Math.floor(this.baseStats.dmg * Math.pow(1.3, this.level - 1) * finalDmgMult);
            }
            
            this.cd = Math.max(10, Math.floor(this.baseStats.spd / finalSpdMult));
            this.hp = Math.min(this.hp, this.maxHp);
        }

        getUpgradeCost() { return Math.floor(this.baseStats.upCost * this.level); }
        
        // ğŸ”¥ ë ˆë²¨ì—… ì‹œ ëª¨ë“œ ì„ íƒ ë°˜ì˜
        levelUp(mode) {
            this.level++;
            
            // í° ì§ì—… ì„ íƒ ë¡œì§
            if (this.type === 'pawn') {
                // ìµœì´ˆ ì„ íƒ ì‹œ ê²½ë¡œ ê³ ì •
                if (this.level === 2 && mode) {
                    this.upgradePath = mode;
                }
                
                // ê²½ë¡œì— ë”°ë¥¸ ìŠ¤íƒ¯ ëˆ„ì 
                if (this.upgradePath === 'berserk') {
                    this.extraHpMult *= 0.9; // ì²´ë ¥ ê°ì†Œ
                    this.extraSpdMult *= 1.15; // ê³µì† ì¦ê°€
                } else if (this.upgradePath === 'tank') {
                    this.extraHpMult *= 1.2; // ì²´ë ¥ ì¦ê°€
                }
            }
            // ğŸ”¥ ë¹„ìˆ ì§ì—… ì„ íƒ ë¡œì§
            else if (this.type === 'bishop') {
                if (this.level === 2 && mode) this.upgradePath = mode;

                if (this.upgradePath === 'rapid') {
                    this.extraDmgMult *= 0.75; // ë€ê° 25%
                    this.extraSpdMult *= 1.40; // ê³µì†ì¦ 40%
                } else if (this.upgradePath === 'power') {
                    this.extraDmgMult *= 1.35; // ğŸ”¥ ë°ë¯¸ì§€ 35% ì¦ê°€
                    this.extraSpdMult *= 0.75; // ğŸ”¥ ê³µì† 25% ê°ì†Œ
                }
            }
            
            this.applyBuffs(); 
            this.hp = this.maxHp; 
        }

        update() {
            if (this.stunTimer > 0) {
                this.stunTimer--;
                return;
            }
            if (isWaveStarting) return; 
            
            this.timer++; if (this.timer % this.cd === 0) this.act();
        }

        act() {
            const cx = this.x + 50, cy = this.y + 50;
            if (this.type === 'king') {
                energy += this.damage; 
                score += this.damage; 
                spawnFloatingText(`+${this.damage.toFixed(1)}`, cx, this.y, '#ffd700'); updateUI(); return;
            }
            
            let finalDmg = this.damage;
            let isCrit = false;
            if (Math.random() < globalBuffs.critChance) {
                finalDmg *= 2;
                isCrit = true;
            }

            if (this.type === 'knight') { 
                 let range = 330 * globalBuffs.rangeMult;
                 let hit = false;
                 enemies.forEach(e => {
                    if (Math.hypot((e.x+50)-cx, (e.y+50)-cy) < range) {
                        e.takeDamage(finalDmg, isCrit, this.type);
                        spawnParticles(e.x+50, e.y+50, 2, '#fff');
                        hit = true;
                    }
                });
                if(hit) this.effect = true;
            } else if (this.type === 'bishop') {
                 projectiles.push(new Projectile(cx, cy, finalDmg, -0.6, this.color, isCrit, this.type));
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0.6, this.color, isCrit, this.type));
            } else if (this.type === 'queen') {
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0, this.color, isCrit, this.type));
                 projectiles.push(new Projectile(cx, cy, finalDmg, -0.6, this.color, isCrit, this.type));
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0.6, this.color, isCrit, this.type));
            } else { 
                let range = (this.type === 'pawn') ? (180 * globalBuffs.rangeMult) : 900;
                if (enemies.some(e => e.y === this.y && e.x > this.x && e.x < this.x + range)) {
                    projectiles.push(new Projectile(cx, cy, finalDmg, 0, this.color, isCrit, this.type));
                }
            }
        }

        draw() {
            ctx.fillStyle = '#333'; ctx.fillRect(this.x+5, this.y+5, 90, 90);
            ctx.fillStyle = this.color; ctx.font = '50px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.icon, this.x+50, this.y+65);
            
            // ğŸ”¥ ì§ì—… ì•„ì´ì½˜
            if (this.upgradePath === 'tank') ctx.fillText('ğŸ›¡ï¸', this.x+20, this.y+30);
            if (this.upgradePath === 'berserk') ctx.fillText('âš”ï¸', this.x+20, this.y+30);
            if (this.upgradePath === 'rapid') ctx.fillText('âš¡', this.x+20, this.y+30);
            if (this.upgradePath === 'power') ctx.fillText('ğŸ”®', this.x+20, this.y+30);

            if (this.stunTimer > 0) {
                ctx.font = '30px Arial'; ctx.fillText('ğŸ’«', this.x+50, this.y+40);
            }

            let stars = "â­".repeat(Math.min(3, this.level)); if (this.level > 3) stars = `â­Lv.${this.level}`;
            ctx.font = '12px Arial'; ctx.fillStyle = '#fff'; ctx.fillText(stars, this.x+50, this.y+20);
            const pct = this.hp/this.maxHp;
            ctx.fillStyle = '#000'; ctx.fillRect(this.x+10, this.y+80, 80, 6);
            ctx.fillStyle = pct > 0.3 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(this.x+10, this.y+80, 80*pct, 6);
            if(this.effect) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); 
                ctx.arc(this.x+50, this.y+50, 330 * globalBuffs.rangeMult / 2, 0, Math.PI*2); ctx.stroke();
                this.effect = false;
            }
        }
    }

    class Enemy {
        constructor(spawnX, spawnY, forcedType) {
            this.y = (spawnY !== undefined) ? spawnY : Math.floor(Math.random() * ROWS) * CELL_SIZE;
            this.x = (spawnX !== undefined) ? spawnX : GAME_WIDTH;
            
            let typeData;
            if (forcedType) {
                typeData = ENEMY_TYPES.find(e => e.type === forcedType) || ENEMY_TYPES[0];
            } else {
                const available = ENEMY_TYPES.filter(e => wave >= e.minWave);
                typeData = available[Math.floor(Math.random() * available.length)];
            }
            
            this.type = typeData.type;
            this.color = typeData.color;
            this.radius = typeData.radius;
            this.ability = typeData.ability;

            // ğŸ”¥ 1% ì¦ê°€ë¡œ ìˆ˜ì • -> ì²´ë ¥ ê¸°ë³¸ 100
            let baseHp = 100 * Math.pow(1.01, wave - 1);
            
            this.hp = baseHp * typeData.hpMult;
            this.maxHp = this.hp;

            // ğŸ”¥ 0.001 ì¦ê°€ë¡œ ìˆ˜ì •
            let baseSpeed = Math.random() * 0.4 + 0.4 + (wave * 0.001);
            this.speed = baseSpeed * typeData.spdMult;
            this.moveSpeed = this.speed;
            
            // ğŸ”¥ ì  ê³µê²©ë ¥ 0.01 ì¦ê°€
            this.damage = 1 + (wave * 0.01);
            
            this.skillTimer = 0;
            this.isSummoning = false;
        }

        update() {
            if (isWaveStarting) return; 

            if (this.isSummoning) {
                this.skillTimer++;
                if (this.skillTimer > 60) {
                    this.doSummon();
                    this.isSummoning = false;
                    this.skillTimer = 0;
                }
                return; 
            }

            this.moveSpeed = this.speed * globalBuffs.enemySpeedMult;
            
            if (this.ability === 'stun') {
                this.skillTimer++;
                if (this.skillTimer > 600) {
                    this.isSummoning = true;
                    this.skillTimer = 0;
                    spawnFloatingText("Summon!", this.x + 50, this.y, '#ffffff', 20);
                }
            } 
            else if (this.ability === 'explode') {
            }

            for (let d of defenders) {
                if (d.y === this.y && this.x < d.x + 80 && this.x > d.x) {
                    this.moveSpeed = 0; 
                    // ì  ê³µê²© ì†ë„: ì´ˆë‹¹ 1íšŒ (60í”„ë ˆì„ ì¤‘ 1ë²ˆ) -> í°ê³¼ ë™ì¼
                    if (frame % 60 === 0) {
                        d.hp -= this.damage;
                    }
                    if (d.hp <= 0) { defenders = defenders.filter(u => u !== d); closeUpgradePanel(); }
                }
            }
            this.x -= this.moveSpeed;
        }

        doSummon() {
            const currentGridX = Math.floor(this.x / CELL_SIZE) * CELL_SIZE;
            const currentGridY = this.y;

            const offsets = [
                { x: -CELL_SIZE, y: 0 },
                { x: 0, y: -CELL_SIZE },
                { x: 0, y: CELL_SIZE }
            ];

            // ì¥êµ° ì†Œí™˜: ìì‹ (boss)ì„ ì œì™¸í•œ íƒ€ì…ë§Œ ì†Œí™˜
            const possibleMinions = ENEMY_TYPES.filter(e => e.type !== 'boss' && wave >= e.minWave);
            const minionTypeData = possibleMinions.length > 0 
                ? possibleMinions[Math.floor(Math.random() * possibleMinions.length)]
                : ENEMY_TYPES[0];

            offsets.forEach(offset => {
                const sx = currentGridX + offset.x;
                const sy = currentGridY + offset.y;

                if (sy >= 0 && sy < GAME_HEIGHT && sx > 0) {
                    enemies.push(new Enemy(sx, sy, minionTypeData.type));
                    spawnParticles(sx + 50, sy + 50, 10, minionTypeData.color);
                }
            });
        }
        
        takeDamage(amount, isCrit, sourceType) { 
            if (this.ability === 'dodge' && Math.random() < 0.3) {
                spawnFloatingText("Miss", this.x+50, this.y, '#ccc', 14);
                return;
            }
            if (this.ability === 'armor') {
                amount = Math.max(1, amount - 10);
                if (Math.random() < 0.3) spawnFloatingText("Block", this.x+50, this.y-20, '#888', 12);
            }
            this.hp -= amount; 
            spawnFloatingText(Math.floor(amount), this.x+50, this.y, isCrit ? '#ff00ff' : '#ff4444', isCrit ? 24 : 18); 
            
            if (this.hp <= 0) this.killedBy = sourceType;
        }
        
        draw() {
            ctx.fillStyle = this.color; 
            ctx.beginPath(); ctx.arc(this.x+50, this.y+50, this.radius, 0, Math.PI*2); ctx.fill();
            
            if (this.isSummoning) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x+50, this.y+50, this.radius + 10, 0, Math.PI*2);
                ctx.stroke();
            }

            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x+35, this.y+45, 8, 0, Math.PI*2); ctx.arc(this.x+65, this.y+45, 8, 0, Math.PI*2); ctx.fill();
            
            let hpY = (this.y < 10) ? this.y + 85 : this.y - 15;

            ctx.fillStyle = '#000'; ctx.fillRect(this.x+20, hpY, 60, 5);
            ctx.fillStyle = this.color; ctx.fillRect(this.x+20, hpY, 60*(this.hp/this.maxHp), 5);
            
            if (globalBuffs.enemySpeedMult < 1.0) {
                 ctx.fillStyle = '#00e5ff'; ctx.font = '12px Arial'; ctx.fillText('â„ï¸', this.x+50, this.y+80);
            }
        }
    }

    class Projectile {
        constructor(x, y, dmg, dy, color, isCrit, sourceType) { 
            this.x = x; this.y = y; this.dmg = dmg; this.dy = dy; this.color = color; 
            this.speed = 10; this.isCrit = isCrit;
            this.sourceType = sourceType; 
        }
        update() { this.x += this.speed; this.y += this.dy * this.speed; }
        draw() { 
            ctx.fillStyle = this.isCrit ? '#fff' : this.color; 
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, this.isCrit ? 10 : 8, 0, Math.PI*2); 
            ctx.fill(); 
            if(this.isCrit) {
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.stroke();
            }
        }
    }

    class FloatingText {
        constructor(text, x, y, color='#fff', size=18) { 
            this.text = text; this.x = x; this.y = y; this.color = color; this.size = size;
            this.life = 1.0; this.dy = -0.5; 
        }
        update() { 
            this.y += this.dy; 
            this.life -= 0.008; 
        }
        draw() { 
            ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; 
            ctx.font = `bold ${this.size}px Arial`; ctx.textAlign='center'; 
            ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0; 
        }
    }
    function spawnFloatingText(text, x, y, color, size) { floatingTexts.push(new FloatingText(text, x, y, color, size)); }

    class Particle {
        constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.vx = (Math.random()-0.5)*5; this.vy = (Math.random()-0.5)*5; this.life = 1.0; }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
    }
    function spawnParticles(x, y, c, color) { for(let i=0; i<c; i++) particles.push(new Particle(x, y, color)); }

    function spawnShockwave(x, y) {
        let wave = new Particle(x, y, '#ffaa00');
        wave.life = 2.0; 
        wave.draw = function() {
            ctx.globalAlpha = Math.max(0, this.life/2);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 330 * (1 - this.life/2), 0, Math.PI*2); 
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
        particles.push(wave);
    }

    function animate() {
        if (!isPlaying) return;
        requestAnimationFrame(animate);
        if (isPaused) return;

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        for (let r=0; r<ROWS; r++) {
            for (let c=0; c<COLS; c++) {
                ctx.fillStyle = (r+c)%2===0 ? '#222' : '#2a2a2a'; ctx.fillRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }
        if (selectedType) { ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3; ctx.strokeRect(0, 0, GAME_WIDTH-CELL_SIZE, GAME_HEIGHT); }
        if (focusedUnit) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.strokeRect(focusedUnit.x, focusedUnit.y, CELL_SIZE, CELL_SIZE); }

        if (!isWaveStarting) {
            if (enemiesSpawned < enemiesToSpawn) {
                let spawnRate = Math.max(60, 300 - (wave * 30)); 
                if (frame % spawnRate === 0) { enemies.push(new Enemy()); enemiesSpawned++; }
            }

            defenders.forEach(d => d.update());
            enemies.forEach((e, i) => {
                e.update();
            });
        }
        
        defenders.sort((a,b) => a.y - b.y);
        defenders.forEach(d => d.draw());

        enemies.forEach((e, i) => {
             e.draw(); 
             
             if (isWaveStarting) return; 

             if (e.x < 0) {
                enemies.splice(i, 1);
                lives--;
                updateUI();
                spawnFloatingText("ğŸ’”", 50, e.y, '#ff0000', 40);
                enemiesKilled++; 
                checkWaveClear();

                if (lives <= 0) {
                    isPlaying = false;
                    document.querySelector('#overlay h1').innerText = "GAME OVER";
                    document.querySelector('#overlay-msg').innerText = "ì ìˆ˜ë¥¼ ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
                    document.getElementById('overlay').style.display = 'flex';
                    document.getElementById('start-btn').style.display = 'none'; 
                    document.getElementById('rank-info').style.display = 'block';
                    document.getElementById('new-record-form').style.display = 'none'; 
                    
                    document.getElementById('res-score').innerText = Math.floor(score);

                    if(window.saveScoreAndCheckRank) {
                        window.saveScoreAndCheckRank(Math.floor(score)).then(res => {
                            document.getElementById('res-rank').innerText = res.rank > 50 ? "50ìœ„ ë°–" : `${res.rank}ìœ„`;
                            document.getElementById('res-top-score').innerText = res.topScore;
                            document.getElementById('res-top-name').innerText = res.topName;
                            
                            const elNextScore = document.getElementById('res-next-score');
                            const elNextRank = document.getElementById('res-next-rank');
                            
                            if (elNextScore && elNextRank) {
                                elNextScore.innerText = res.nextScore;
                                elNextRank.innerText = res.nextRankInfo;
                            }

                            document.querySelector('#overlay-msg').innerText = "ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!";
                            document.getElementById('start-btn').innerText = "ë‹¤ì‹œ í•˜ê¸°";
                            document.getElementById('start-btn').style.display = 'block';

                            window.currentDocId = res.docId;
                            if (res.isNewRecord) {
                                document.getElementById('new-record-form').style.display = 'block';
                            }
                        });
                    }
                }
            } else if (e.hp <= 0) {
                if (e.ability === 'explode') {
                    // ğŸ”¥ ìí­ ë°ë¯¸ì§€ ìˆ˜ì • (ê¸°ë³¸ 80 + 5ì›¨ì´ë¸Œë§ˆë‹¤ 10ì¦ê°€)
                    let explosionDmg = 80 + (Math.floor(wave / 5) * 10);
                    spawnShockwave(e.x + 50, e.y + 50); 
                    defenders.forEach(d => {
                        const dist = Math.hypot((d.x+50)-(e.x+50), (d.y+50)-(e.y+50));
                        if (dist < 330) {
                            d.hp -= explosionDmg; 
                            spawnFloatingText(`-${explosionDmg}`, d.x+50, d.y, '#ff4400', 20);
                            if (d.hp <= 0) { 
                                defenders = defenders.filter(u => u !== d); 
                                closeUpgradePanel(); 
                            }
                        }
                    });
                }

                enemies.splice(i, 1); 
                let gain = 10 + globalBuffs.goldPerKill;
                
                if (globalBuffs.pawnLoot && e.killedBy === 'pawn') {
                    gain += 1;
                    spawnFloatingText("+1 Loot", e.x+50, e.y, '#ffff00', 14);
                }

                energy += gain; 
                score += gain; 
                enemiesKilled++; updateUI();
                spawnParticles(e.x+50, e.y+50, 10, '#e74c3c');
                checkWaveClear();
            }
        });

        projectiles.forEach((p, i) => {
            if (!isWaveStarting) p.update();
            p.draw();
            
            if (isWaveStarting) return;

            if (p.x > GAME_WIDTH || p.y < 0 || p.y > GAME_HEIGHT) { projectiles.splice(i, 1); return; }
            for (let e of enemies) {
                if (Math.hypot((e.x+50)-p.x, (e.y+50)-p.y) < (40 + e.radius - 35)) {
                    e.takeDamage(p.dmg, p.isCrit, p.sourceType); 
                    spawnParticles(p.x, p.y, 3, p.color); projectiles.splice(i, 1); break;
                }
            }
        });
        
        particles.forEach((p, i) => { 
            if (!isWaveStarting) p.update(); 
            p.draw(); 
            if (p.life <= 0) particles.splice(i, 1); 
        });
        floatingTexts.forEach((t, i) => { 
            if (!isWaveStarting) t.update(); 
            t.draw(); 
            if (t.life <= 0) floatingTexts.splice(i, 1); 
        });

        if (!isWaveStarting) frame++;
    }
</script>
</body>
</html>
