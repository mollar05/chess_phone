<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess Defense: Final Fixed</title>
    <style>
        /* ëª¨ë°”ì¼ ê¸°ë³¸ ì„¤ì • */
        body {
            background-color: #121212;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* ìƒë‹¨ HUD */
        #top-hud {
            height: 50px;
            background: #1e1e1e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .hud-item {
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .energy-count { color: #ffd700; font-size: 20px; }
        .score-display { color: #fff; font-size: 14px; margin-left: 10px; }
        .life-display { color: #ff4444; font-size: 18px; margin-left: 10px; display: flex; align-items: center; gap: 3px; }
        .wave-text { color: #00e5ff; font-size: 16px; margin-left: 5px; text-shadow: 0 0 5px #00e5ff;}
        .progress-bar-bg { width: 60px; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-left: 10px; }
        .progress-bar-fill { height: 100%; background: #ff4444; width: 0%; transition: width 0.3s; }

        /* ê²Œì„ ìº”ë²„ìŠ¤ ì˜ì—­ */
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2a2a2a;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 900/500;
        }

        /* ğŸƒ ì¹´ë“œ ì„ íƒ ì˜¤ë²„ë ˆì´ */
        #card-selection {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 60;
        }
        
        #card-selection h2 { color: #ffd700; margin-bottom: 15px; font-size: 6vw; text-shadow: 0 0 10px #ffd700; }
        #card-selection p { font-size: 3.5vw; color: #ccc; margin-bottom: 15px; }

        .cards-container {
            display: flex;
            justify-content: center;
            gap: 2%;
            width: 95%;
            height: 60%;
        }

        .card {
            background: linear-gradient(145deg, #2a2a2a, #333);
            border: 2px solid #555;
            border-radius: 12px;
            width: 31%;
            height: 100%;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            box-sizing: border-box;
        }

        .card:active { transform: scale(0.95); border-color: #ffd700; background: #3a3a3a; }
        
        .card-icon { font-size: 8vw; margin-bottom: 5px; margin-top: 10px;}
        .card-title { font-weight: bold; color: #fff; margin-bottom: 5px; font-size: 3.5vw; white-space: nowrap;}
        .card-desc { font-size: 2.8vw; color: #ccc; line-height: 1.3; padding: 0 5px; word-break: keep-all; flex: 1; display: flex; align-items: center; justify-content: center;}
        .card-rare { color: #ffd700; font-size: 2.5vw; margin-top: 5px; margin-bottom: 10px; border: 1px solid #ffd700; padding: 2px 8px; border-radius: 10px;}

        @media (min-width: 600px) {
            #card-selection h2 { font-size: 30px; }
            #card-selection p { font-size: 16px; }
            .card-icon { font-size: 50px; }
            .card-title { font-size: 18px; }
            .card-desc { font-size: 14px; }
            .card-rare { font-size: 12px; }
            .cards-container { width: 80%; height: 50%; gap: 20px;}
            .card { width: 160px; height: 240px; }
        }

        /* ì—…ê·¸ë ˆì´ë“œ íŒ¨ë„ */
        #upgrade-panel {
            position: absolute;
            bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700; border-radius: 15px;
            padding: 15px;
            display: none;
            flex-direction: column; align-items: center;
            z-index: 50; width: 60%; max-width: 300px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        .action-btn { padding: 12px; border:none; border-radius:8px; width:100%; margin-top:8px; font-weight:bold; cursor:pointer; font-size: 14px;}
        .btn-upgrade { background:#ffd700; color:#000; }
        .btn-sell { background: #e74c3c; color: white; }
        .btn-close { background:#444; color:#fff; }

        /* í•˜ë‹¨ ìœ ë‹› ì„ íƒ ë°” */
        #bottom-bar {
            height: 90px;
            background: #1e1e1e;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
            border-top: 2px solid #333;
            z-index: 10;
        }

        .unit-btn {
            background: #333;
            border: 2px solid #444;
            border-radius: 8px;
            width: 15%;
            height: 90%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .unit-btn.selected { border-color: #ffd700; background: #4a4a3a; }
        .unit-btn.disabled { opacity: 0.4; filter: grayscale(100%); }
        .unit-cost { font-size: 11px; color: #ffd700; font-weight: bold; }

        /* ì˜¤ë²„ë ˆì´ (ê²Œì„ì˜¤ë²„/ì‹œì‘) */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }
        .big-btn { padding: 15px 40px; font-size: 24px; background: #ffd700; border: none; border-radius: 30px; font-weight: bold; cursor: pointer; margin-top: 20px; }
        
        #rank-info {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 15px;
            width: 80%;
            max-width: 300px;
            border: 1px solid #555;
        }
        .rank-stat { font-size: 18px; color: #ccc; margin: 5px 0; }
        .rank-val { color: #ffd700; font-weight: bold; font-size: 22px; }

        /* 1ë“± ì´ë¦„ ì…ë ¥ í¼ */
        #new-record-form {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
            margin-top: 15px;
            text-align: center;
            animation: popIn 0.5s ease;
        }
        @keyframes popIn { from {transform: scale(0.5); opacity: 0;} to {transform: scale(1); opacity: 1;} }
        
        #player-name-input {
            padding: 10px; font-size: 16px; border-radius: 5px; border: none; width: 70%; margin-bottom: 10px;
        }
        .submit-btn {
            background: #00e5ff; color: #000; padding: 10px 20px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer;
        }

    </style>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, serverTimestamp, updateDoc, doc, limit, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ğŸ”¥ ë‹˜ì˜ Firebase ì„¤ì •
        const firebaseConfig = {
            apiKey: "AIzaSyAQc4zmexSGF19tSTJs6pTgtFOE0z--6XA",
            authDomain: "game-28340361-cd827.firebaseapp.com",
            projectId: "game-28340361-cd827",
            storageBucket: "game-28340361-cd827.firebasestorage.app",
            messagingSenderId: "642880657235",
            appId: "1:642880657235:web:b0b00984a8b5590f1bb3a6"
        };

        // Firebase ì´ˆê¸°í™”
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            
            signInAnonymously(auth).then(() => {
                console.log("Firebase ë¡œê·¸ì¸ ì„±ê³µ!");
            }).catch(e => {
                console.error("Firebase Login Failed:", e);
            });

        } catch(e) {
            console.error("Firebase Init Error:", e);
        }

        // ì¸ì¦ ëŒ€ê¸°ìš© Promise
        const authReady = new Promise((resolve) => {
            if(!auth) return resolve(null);
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    resolve(user);
                }
            });
        });

        // ì ìˆ˜ ì €ì¥ ë° ë­í‚¹ ì¡°íšŒ
        window.saveScoreAndCheckRank = async (finalScore) => {
            if (!db) return { rank: 'ì„¤ì • ì˜¤ë¥˜', topScore: '-', topName: '-', isNewRecord: false };

            try {
                await authReady; // ë¡œê·¸ì¸ ëŒ€ê¸°
                const uid = auth.currentUser ? auth.currentUser.uid : 'guest';
                const colRef = collection(db, 'scores');

                // 1. ë‚´ ì ìˆ˜ ì €ì¥
                const docRef = await addDoc(colRef, {
                    score: finalScore,
                    name: "Unknown",
                    ts: serverTimestamp(),
                    uid: uid
                });

                // 2. ì „ì²´ ì ìˆ˜ ê°€ì ¸ì™€ì„œ ë­í‚¹ ì‚°ì • (ë‹¨ìˆœ êµ¬í˜„)
                const snapshot = await getDocs(colRef);
                let scores = [];
                snapshot.forEach(d => scores.push({ ...d.data(), id: d.id }));
                
                scores.sort((a, b) => b.score - a.score);

                const myRank = scores.findIndex(s => s.id === docRef.id) + 1;
                const topPlayer = scores[0];

                return {
                    rank: myRank,
                    topScore: topPlayer ? topPlayer.score : finalScore,
                    topName: topPlayer ? topPlayer.name : "Unknown",
                    isNewRecord: (myRank === 1),
                    docId: docRef.id
                };

            } catch (e) {
                console.error("Ranking System Error:", e);
                if(e.code === 'permission-denied') {
                    alert("ë°ì´í„°ë² ì´ìŠ¤ ê¶Œí•œ ì˜¤ë¥˜!\nFirebase Console -> Rulesì—ì„œ ê·œì¹™ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.");
                }
                return { rank: 'Error', topScore: '-', topName: '-', isNewRecord: false };
            }
        };

        // ì´ë¦„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        window.updatePlayerName = async (docId, newName) => {
            if (!db || !docId) return;
            try {
                const docRef = doc(db, 'scores', docId);
                await updateDoc(docRef, { name: newName });
                return true;
            } catch(e) {
                console.error("Name Update Error:", e);
                return false;
            }
        };

        // ğŸ”¥ submitName í•¨ìˆ˜ ì „ì—­ ë“±ë¡ (HTML ë²„íŠ¼ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ê²Œ)
        window.submitName = () => {
            const nameInput = document.getElementById('player-name-input');
            const name = nameInput.value.trim();
            if (!name || name.length > 8) {
                alert("ì´ë¦„ì„ 1~8ê¸€ìë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                return;
            }
            
            // ì „ì—­ ë³€ìˆ˜ window.currentDocId ì‚¬ìš©
            if (window.currentDocId && window.updatePlayerName) {
                window.updatePlayerName(window.currentDocId, name).then(() => {
                    const elName = document.getElementById('res-top-name');
                    if(elName) elName.innerText = name;
                    
                    const form = document.getElementById('new-record-form');
                    if(form) form.innerHTML = "<h4 style='color:#00e5ff'>ì´ë¦„ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!</h4>";
                });
            } else {
                console.error("Document ID not found");
            }
        };
    </script>
</head>
<body>

    <div id="top-hud">
        <div class="hud-item">
            <span>âš¡</span><span class="energy-count" id="ui-energy">150</span>
            <!-- ì ìˆ˜ í‘œì‹œ UI ë³µêµ¬ -->
            <span class="score-display">(ì ìˆ˜: <span id="ui-score">0</span>)</span>
            <span class="life-display">â¤ï¸ <span id="ui-lives">1</span></span>
        </div>
        <div class="hud-item">
            <span class="wave-text" id="ui-wave">Wave 1</span>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="wave-progress"></div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- ì¹´ë“œ ì„ íƒ UI -->
        <div id="card-selection">
            <h2>ğŸ‰ Wave Clear!</h2>
            <p>ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”</p>
            <div class="cards-container" id="cards-box"></div>
        </div>

        <!-- ìœ ë‹› ê°œë³„ ì—…ê·¸ë ˆì´ë“œ UI -->
        <div id="upgrade-panel">
            <div id="upgrade-info" style="font-weight:bold; font-size:18px; color:#ffd700; margin-bottom:5px;">Lv.1 í°</div>
            <div id="upgrade-stats" style="color:#ccc; font-size:12px; margin-bottom:5px;">ìŠ¤íƒ¯ ì •ë³´</div>
            <button class="action-btn btn-upgrade" id="btn-do-upgrade" onclick="upgradeSelectedUnit()">ê°•í™”</button>
            <button class="action-btn btn-sell" id="btn-do-sell" onclick="sellSelectedUnit()">íŒë§¤</button>
            <button class="action-btn btn-close" onclick="closeUpgradePanel()">ë‹«ê¸°</button>
        </div>

        <!-- ì‹œì‘/ì¢…ë£Œ í™”ë©´ -->
        <div id="overlay">
            <h1 style="color:#ffd700; margin-bottom:10px; font-size:32px;">ğŸƒ Chess Defense</h1>
            <p id="overlay-msg" style="color:#ccc; text-align:center; margin-bottom:20px; line-height:1.5;">
                ì ë“¤ì˜ ê³µê²© ì†ë„ê°€ ì¡°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤.<br>
                1ë“±ì— ë„ì „í•˜ì„¸ìš”!
            </p>
            
            <!-- ë­í‚¹ í‘œì‹œ ì˜ì—­ -->
            <div id="rank-info" style="display:none;">
                <div class="rank-stat">ë‚´ ì ìˆ˜</div>
                <div class="rank-val" id="res-score">0</div>
                <hr style="border-color:#444; margin:10px 0;">
                <div class="rank-stat">ë‚´ ìˆœìœ„</div>
                <div class="rank-val" id="res-rank" style="color:#00e5ff;">ê³„ì‚° ì¤‘...</div>
                
                <div class="rank-stat" style="font-size:14px; margin-top:15px; color:#aaa;">
                    ğŸ‘‘ Current Champion ğŸ‘‘<br>
                    <span id="res-top-name" style="color:#ffd700; font-weight:bold;">Unknown</span> : 
                    <span id="res-top-score" style="color:#fff;">0</span>
                </div>

                <div id="new-record-form">
                    <h3 style="color:#ffd700; margin:10px 0;">ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! 1ë“±ì…ë‹ˆë‹¤! ğŸ‰</h3>
                    <input type="text" id="player-name-input" placeholder="ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ìµœëŒ€ 8ì)" maxlength="8">
                    <!-- submitName í•¨ìˆ˜ëŠ” ì „ì—­ window ê°ì²´ì— ë“±ë¡ë˜ì–´ ìˆìŒ -->
                    <button class="submit-btn" onclick="submitName()">ê¸°ë¡ ë‚¨ê¸°ê¸°</button>
                </div>
            </div>

            <button class="big-btn" id="start-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <div id="bottom-bar">
        <div class="unit-btn" id="btn-king" onclick="selectUnitType('king')">
            <div class="unit-icon" style="font-size:24px">â™š</div>
            <div class="unit-cost">100</div>
            <div style="font-size:9px; color:#ccc">í‚¹(ìì›)</div>
        </div>
        <div class="unit-btn" id="btn-pawn" onclick="selectUnitType('pawn')">
            <div class="unit-icon" style="font-size:24px">â™Ÿï¸</div>
            <div class="unit-cost">50</div>
            <div style="font-size:9px; color:#ccc">í°(ë°©íŒ¨)</div>
        </div>
        <div class="unit-btn" id="btn-rook" onclick="selectUnitType('rook')">
            <div class="unit-icon" style="font-size:24px">â™œ</div>
            <div class="unit-cost">370</div>
            <div style="font-size:9px; color:#ccc">ë£©(ì§ì„ )</div>
        </div>
        <div class="unit-btn" id="btn-bishop" onclick="selectUnitType('bishop')">
            <div class="unit-icon" style="font-size:24px">â™</div>
            <div class="unit-cost">120</div>
            <div style="font-size:9px; color:#ccc">ë¹„ìˆ(ëŒ€ê°)</div>
        </div>
        <div class="unit-btn" id="btn-knight" onclick="selectUnitType('knight')">
            <div class="unit-icon" style="font-size:24px">â™</div>
            <div class="unit-cost">500</div>
            <div style="font-size:9px; color:#ccc">ë‚˜ì´íŠ¸(ë²”ìœ„)</div>
        </div>
        <div class="unit-btn" id="btn-queen" onclick="selectUnitType('queen')">
            <div class="unit-icon" style="font-size:24px">â™›</div>
            <div class="unit-cost">1500</div>
            <div style="font-size:9px; color:#ccc">í€¸(ë©€í‹°)</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GAME_WIDTH = 900;
    const GAME_HEIGHT = 500;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    const CELL_SIZE = 100;
    const COLS = 9;
    const ROWS = 5;

    let isPlaying = false;
    let isPaused = false;
    let energy = 150;
    let score = 0; 
    let lives = 1; 
    let frame = 0;
    
    let wave = 1;
    let enemiesToSpawn = 0;
    let enemiesSpawned = 0;
    let enemiesKilled = 0;
    let waveTotalEnemies = 0;

    let globalBuffs = { 
        dmgMult: 1.0, spdMult: 1.0, costMult: 1.0, hpMult: 1.0, kingGold: 0,
        enemySpeedMult: 1.0, goldPerKill: 0, rangeMult: 1.0, critChance: 0, sellRefund: 0.5
    };

    let selectedType = null;
    let focusedUnit = null;

    let defenders = [];
    let enemies = [];
    let projectiles = [];
    let particles = [];
    let floatingTexts = [];

    window.currentDocId = null;

    const UNITS = {
        'king':   { cost: 100,  hp: 200, dmg: 0.2, spd: 120, upCost: 100, color: '#ffd700', icon: 'â™š', name: 'í‚¹' },
        'pawn':   { cost: 50,  hp: 400, dmg: 10,  spd: 60,  upCost: 30,  color: '#aaa',    icon: 'â™Ÿï¸', name: 'í°' },
        'rook':   { cost: 370, hp: 200, dmg: 30,  spd: 90,  upCost: 120, color: '#4a90e2', icon: 'â™œ', name: 'ë£©' },
        'bishop': { cost: 120, hp: 150, dmg: 40,  spd: 60,  upCost: 150, color: '#9013fe', icon: 'â™', name: 'ë¹„ìˆ' },
        'knight': { cost: 500, hp: 300, dmg: 18,  spd: 40,  upCost: 200, color: '#7ed321', icon: 'â™', name: 'ë‚˜ì´íŠ¸' },
        'queen':  { cost: 1500, hp: 500, dmg: 25,  spd: 45,  upCost: 300, color: '#ff00ff', icon: 'â™›', name: 'í€¸' }
    };

    const CARD_POOL = [
        { id: 'atk_up',   icon: 'âš”ï¸', title: 'ì „êµ° ëŒê²©', desc: 'ì•„êµ° ê³µê²©ë ¥ +20%' },
        { id: 'spd_up',   icon: 'âš¡', title: 'ê´‘ì† ëª¨ë“œ', desc: 'ì•„êµ° ê³µì† +15%' },
        { id: 'hp_up',    icon: 'ğŸ›¡ï¸', title: 'ê°•ì²  ê°‘ì˜·', desc: 'ì•„êµ° ì²´ë ¥ +25%' },
        { id: 'cost_dn',  icon: 'ğŸ’°', title: 'ìì› ì ˆì•½', desc: 'ë°°ì¹˜ ë¹„ìš© -10%' },
        { id: 'king_up',  icon: 'ğŸ‘‘', title: 'ì™•ì˜ ì„¸ê¸ˆ', desc: 'í‚¹ ìì›ìƒì‚° +0.2' },
        { id: 'rich',     icon: 'ğŸ’', title: 'ë³´ê¸‰í’ˆ',    desc: 'ì¦‰ì‹œ ìì› +200' },
        { id: 'heal_all', icon: 'ğŸ’Š', title: 'ê¸´ê¸‰ ìˆ˜ë¦¬', desc: 'ëª¨ë“  ì•„êµ° ì²´ë ¥ 100% íšŒë³µ' },
        { id: 'slow',     icon: 'â„ï¸', title: 'ì–¼ìŒ ì§€ëŒ€', desc: 'ì  ì´ë™ì†ë„ -10%' },
        { id: 'bounty',   icon: 'ğŸ’°', title: 'í˜„ìƒê¸ˆ',    desc: 'ì  ì²˜ì¹˜ ì‹œ +3ê³¨ë“œ' },
        { id: 'range',    icon: 'ğŸ”­', title: 'ì €ê²© í›ˆë ¨', desc: 'í°/ë‚˜ì´íŠ¸ ì‚¬ê±°ë¦¬ +20%' },
        { id: 'crit',     icon: 'âš¡', title: 'ì¹˜ëª…íƒ€',    desc: '10% í™•ë¥ ë¡œ 2ë°° ë°ë¯¸ì§€' },
        { id: 'recycle',  icon: 'â™»ï¸', title: 'ì¬í™œìš©',    desc: 'íŒë§¤ í™˜ê¸‰ë¥  80%ë¡œ ì¦ê°€' },
        { id: 'life_up',  icon: 'â¤ï¸', title: 'ëª©ìˆ¨+1!!',  desc: 'ê¸°ì§€ ìƒëª…ë ¥ +1' }
    ];

    const ENEMY_TYPES = [
        { minWave: 1,  type: 'normal', color: '#e74c3c', hpMult: 1.0, spdMult: 1.0, radius: 35, ability: null },
        { minWave: 3,  type: 'bomber', color: '#ff6600', hpMult: 0.8, spdMult: 1.3, radius: 30, ability: 'explode' }, 
        { minWave: 5,  type: 'fast',   color: '#f1c40f', hpMult: 0.6, spdMult: 1.5, radius: 25, ability: 'dodge' },
        { minWave: 10, type: 'tank',   color: '#8e44ad', hpMult: 2.5, spdMult: 0.6, radius: 45, ability: 'armor' },
        { minWave: 15, type: 'boss',   color: '#2c3e50', hpMult: 5.0, spdMult: 0.4, radius: 50, ability: 'stun' }
    ];

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('rank-info').style.display = 'none'; 
        document.getElementById('new-record-form').style.display = 'none';
        initGame();
        startWave(1);
        animate();
    }

    function initGame() {
        defenders = []; enemies = []; projectiles = []; particles = []; floatingTexts = [];
        energy = 150; score = 0; lives = 1; 
        frame = 0; isPlaying = true; isPaused = false;
        globalBuffs = { 
            dmgMult: 1.0, spdMult: 1.0, costMult: 1.0, hpMult: 1.0, kingGold: 0,
            enemySpeedMult: 1.0, goldPerKill: 0, rangeMult: 1.0, critChance: 0, sellRefund: 0.5
        };
        closeUpgradePanel();
        updateUI();
    }

    function startWave(waveNum) {
        wave = waveNum; enemiesSpawned = 0; enemiesKilled = 0;
        
        waveTotalEnemies = 5 + Math.floor(wave * 3); 
        
        let isHorde = Math.random() < 0.05;
        if (isHorde) {
            waveTotalEnemies *= 2;
            spawnFloatingText("âš ï¸ ëŒ€ê·œëª¨ ì›¨ì´ë¸Œ! âš ï¸", GAME_WIDTH/2, GAME_HEIGHT/2, '#ff0000', 30);
        } else {
            spawnFloatingText(`Wave ${wave} Start!`, GAME_WIDTH/2, GAME_HEIGHT/2, '#00e5ff');
        }

        enemiesToSpawn = waveTotalEnemies;
        updateUI();
    }

    function checkWaveClear() {
        if (enemiesKilled >= waveTotalEnemies) showCardSelection();
    }

    function showCardSelection() {
        isPaused = true;
        const cardBox = document.getElementById('cards-box');
        cardBox.innerHTML = ''; 
        const shuffled = [...CARD_POOL].sort(() => 0.5 - Math.random());
        const picks = shuffled.slice(0, 3);

        picks.forEach(card => {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `
                <div class="card-icon">${card.icon}</div>
                <div class="card-title">${card.title}</div>
                <div class="card-desc">${card.desc}</div>
                <div class="card-rare">ì„ íƒ</div>
            `;
            el.onclick = () => selectCard(card.id);
            cardBox.appendChild(el);
        });
        document.getElementById('card-selection').style.display = 'flex';
    }

    function selectCard(cardId) {
        switch(cardId) {
            case 'atk_up': globalBuffs.dmgMult += 0.2; break;
            case 'spd_up': globalBuffs.spdMult += 0.15; break;
            case 'hp_up':  globalBuffs.hpMult += 0.25; break;
            case 'cost_dn': globalBuffs.costMult *= 0.9; break;
            case 'king_up': globalBuffs.kingGold += 0.2; break;
            case 'rich': energy += 200; score += 200; break;
            case 'heal_all': defenders.forEach(d => { d.hp = d.maxHp; spawnFloatingText("Heal!", d.x+50, d.y, '#00ff00'); }); break;
            case 'slow': globalBuffs.enemySpeedMult *= 0.9; break;
            case 'bounty': globalBuffs.goldPerKill += 3; break;
            case 'range': globalBuffs.rangeMult += 0.2; break;
            case 'crit': globalBuffs.critChance += 0.1; break;
            case 'recycle': globalBuffs.sellRefund = 0.8; break;
            case 'life_up': 
                lives++; 
                spawnFloatingText("ëª©ìˆ¨ +1", GAME_WIDTH/2, GAME_HEIGHT/2, '#ff4444', 30);
                break;
        }
        defenders.forEach(d => d.applyBuffs());
        document.getElementById('card-selection').style.display = 'none';
        isPaused = false;
        startWave(wave + 1);
        updateUI();
    }

    function updateUI() {
        // ğŸ”¥ UI ìš”ì†Œ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸° (null ì²´í¬)
        const elEnergy = document.getElementById('ui-energy');
        const elScore = document.getElementById('ui-score');
        const elLives = document.getElementById('ui-lives');
        const elWave = document.getElementById('ui-wave');
        const elProgress = document.getElementById('wave-progress');

        if(elEnergy) elEnergy.innerText = Math.floor(energy);
        if(elScore) elScore.innerText = Math.floor(score);
        if(elLives) elLives.innerText = lives;
        if(elWave) elWave.innerText = `Wave ${wave}`;
        
        if(elProgress) {
            const progress = Math.min(100, (enemiesKilled / waveTotalEnemies) * 100);
            elProgress.style.width = `${progress}%`;
        }

        ['king', 'pawn', 'rook', 'bishop', 'knight', 'queen'].forEach(t => {
            const btn = document.getElementById(`btn-${t}`);
            if (btn) {
                const realCost = Math.floor(UNITS[t].cost * globalBuffs.costMult);
                const costDisplay = btn.querySelector('.unit-cost');
                if (costDisplay) costDisplay.innerText = realCost;
                
                if (selectedType === t) btn.classList.add('selected'); else btn.classList.remove('selected');
                if (energy < realCost) btn.classList.add('disabled'); else btn.classList.remove('disabled');
            }
        });
    }

    window.selectUnitType = function(type) {
        if (!isPlaying || isPaused) return;
        if (selectedType === type) selectedType = null;
        else selectedType = type;
        closeUpgradePanel();
        updateUI();
    };

    function handleInput(cx, cy) {
        if (!isPlaying || isPaused) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (cx - rect.left) * scaleX;
        const y = (cy - rect.top) * scaleY;
        const gx = Math.floor(x / CELL_SIZE) * CELL_SIZE;
        const gy = Math.floor(y / CELL_SIZE) * CELL_SIZE;

        if (gx >= GAME_WIDTH - CELL_SIZE || gx < 0 || gy < 0 || gy >= GAME_HEIGHT) {
            selectedType = null; closeUpgradePanel(); updateUI(); return;
        }

        const clickedUnit = defenders.find(d => d.x === gx && d.y === gy);

        if (clickedUnit) {
            openUpgradePanel(clickedUnit);
            selectedType = null;
        } else if (selectedType) {
            const baseCost = UNITS[selectedType].cost;
            const finalCost = Math.floor(baseCost * globalBuffs.costMult);
            if (energy >= finalCost) {
                defenders.push(new Defender(gx, gy, selectedType));
                energy -= finalCost;
                spawnParticles(gx+50, gy+50, 10, '#ffd700');
                selectedType = null; updateUI();
            }
        } else {
            closeUpgradePanel();
        }
    }

    function openUpgradePanel(unit) {
        focusedUnit = unit;
        const panel = document.getElementById('upgrade-panel');
        const nextCost = unit.getUpgradeCost();
        
        const baseCost = UNITS[unit.type].cost;
        const invest = baseCost + ((unit.level - 1) * UNITS[unit.type].upCost);
        const sellPrice = Math.floor(invest * globalBuffs.sellRefund);

        document.getElementById('upgrade-info').innerText = `Lv.${unit.level} ${UNITS[unit.type].name}`;
        
        let statText = "";
        if (unit.type === 'king') {
            statText = `ìƒì‚°ëŸ‰: ${unit.damage.toFixed(1)} -> ${(unit.damage + 0.2).toFixed(1)}`;
        } else {
            statText = `ê³µê²©ë ¥: ${unit.damage} -> ${Math.floor(unit.damage * 1.3)}`;
        }
        document.getElementById('upgrade-stats').innerText = statText;
        
        const btnUp = document.getElementById('btn-do-upgrade');
        btnUp.innerText = `ê°•í™” (${nextCost}G)`;
        btnUp.style.opacity = (energy < nextCost) ? 0.5 : 1.0;

        const btnSell = document.getElementById('btn-do-sell');
        btnSell.innerText = `íŒë§¤ (+${sellPrice}G)`;

        panel.style.display = 'flex';
    }

    window.closeUpgradePanel = () => { document.getElementById('upgrade-panel').style.display = 'none'; focusedUnit = null; };
    
    window.upgradeSelectedUnit = () => {
        if (!focusedUnit) return;
        const cost = focusedUnit.getUpgradeCost();
        if (energy >= cost) {
            energy -= cost;
            focusedUnit.levelUp();
            spawnParticles(focusedUnit.x+50, focusedUnit.y+50, 20, '#fff');
            spawnFloatingText("LEVEL UP!", focusedUnit.x+50, focusedUnit.y);
            openUpgradePanel(focusedUnit); updateUI();
        }
    };

    window.sellSelectedUnit = () => {
        if (!focusedUnit) return;
        const baseCost = UNITS[focusedUnit.type].cost;
        const invest = baseCost + ((focusedUnit.level - 1) * UNITS[focusedUnit.type].upCost);
        const sellPrice = Math.floor(invest * globalBuffs.sellRefund);

        energy += sellPrice;
        spawnFloatingText(`+${sellPrice} G`, focusedUnit.x+50, focusedUnit.y, '#ffd700');
        spawnParticles(focusedUnit.x+50, focusedUnit.y+50, 15, '#888');

        defenders = defenders.filter(d => d !== focusedUnit);
        closeUpgradePanel();
        updateUI();
    };

    canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

    class Defender {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.level = 1; this.baseStats = UNITS[type];
            this.color = this.baseStats.color; this.icon = this.baseStats.icon;
            this.timer = 0; this.applyBuffs(); this.hp = this.maxHp;
            this.stunTimer = 0;
        }

        applyBuffs() {
            const lvlMult = Math.pow(1.2, this.level - 1);
            this.maxHp = Math.floor(this.baseStats.hp * lvlMult * globalBuffs.hpMult);
            
            if (this.type === 'king') {
                this.damage = 0.2 + ((this.level-1) * 0.2) + globalBuffs.kingGold;
            } else {
                this.damage = Math.floor(this.baseStats.dmg * Math.pow(1.3, this.level - 1) * globalBuffs.dmgMult);
            }
            this.cd = Math.max(10, Math.floor(this.baseStats.spd / globalBuffs.spdMult));
            this.hp = Math.min(this.hp, this.maxHp);
        }

        getUpgradeCost() { return Math.floor(this.baseStats.upCost * this.level); }
        levelUp() { this.level++; this.applyBuffs(); this.hp = this.maxHp; }

        update() {
            if (this.stunTimer > 0) {
                this.stunTimer--;
                return;
            }
            this.timer++; if (this.timer % this.cd === 0) this.act();
        }

        act() {
            const cx = this.x + 50, cy = this.y + 50;
            if (this.type === 'king') {
                energy += this.damage; 
                score += this.damage; 
                spawnFloatingText(`+${this.damage.toFixed(1)}`, cx, this.y, '#ffd700'); updateUI(); return;
            }
            
            let finalDmg = this.damage;
            let isCrit = false;
            if (Math.random() < globalBuffs.critChance) {
                finalDmg *= 2;
                isCrit = true;
            }

            if (this.type === 'knight') { 
                 let range = 330 * globalBuffs.rangeMult;
                 let hit = false;
                 enemies.forEach(e => {
                    if (Math.hypot((e.x+50)-cx, (e.y+50)-cy) < range) {
                        e.takeDamage(finalDmg, isCrit);
                        spawnParticles(e.x+50, e.y+50, 2, '#fff');
                        hit = true;
                    }
                });
                if(hit) this.effect = true;
            } else if (this.type === 'bishop') {
                 projectiles.push(new Projectile(cx, cy, finalDmg, -0.6, this.color, isCrit));
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0.6, this.color, isCrit));
            } else if (this.type === 'queen') {
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0, this.color, isCrit));
                 projectiles.push(new Projectile(cx, cy, finalDmg, -0.6, this.color, isCrit));
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0.6, this.color, isCrit));
            } else { 
                let range = (this.type === 'pawn') ? (180 * globalBuffs.rangeMult) : 900;
                if (enemies.some(e => e.y === this.y && e.x > this.x && e.x < this.x + range)) {
                    projectiles.push(new Projectile(cx, cy, finalDmg, 0, this.color, isCrit));
                }
            }
        }

        draw() {
            ctx.fillStyle = '#333'; ctx.fillRect(this.x+5, this.y+5, 90, 90);
            ctx.fillStyle = this.color; ctx.font = '50px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.icon, this.x+50, this.y+65);
            
            if (this.stunTimer > 0) {
                ctx.font = '30px Arial'; ctx.fillText('ğŸ’«', this.x+50, this.y+40);
            }

            let stars = "â­".repeat(Math.min(3, this.level)); if (this.level > 3) stars = `â­Lv.${this.level}`;
            ctx.font = '12px Arial'; ctx.fillStyle = '#fff'; ctx.fillText(stars, this.x+50, this.y+20);
            const pct = this.hp/this.maxHp;
            ctx.fillStyle = '#000'; ctx.fillRect(this.x+10, this.y+80, 80, 6);
            ctx.fillStyle = pct > 0.3 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(this.x+10, this.y+80, 80*pct, 6);
            if(this.effect) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); 
                ctx.arc(this.x+50, this.y+50, 330 * globalBuffs.rangeMult / 2, 0, Math.PI*2); ctx.stroke();
                this.effect = false;
            }
        }
    }

    class Enemy {
        constructor(spawnX, spawnY, forcedType) {
            this.y = (spawnY !== undefined) ? spawnY : Math.floor(Math.random() * ROWS) * CELL_SIZE;
            this.x = (spawnX !== undefined) ? spawnX : GAME_WIDTH;
            
            let typeData;
            if (forcedType) {
                typeData = ENEMY_TYPES.find(e => e.type === forcedType) || ENEMY_TYPES[0];
            } else {
                const available = ENEMY_TYPES.filter(e => wave >= e.minWave);
                typeData = available[Math.floor(Math.random() * available.length)];
            }
            
            this.type = typeData.type;
            this.color = typeData.color;
            this.radius = typeData.radius;
            this.ability = typeData.ability;

            let baseHp = 150 * Math.pow(1.05, wave - 1);
            if (wave === 1) baseHp *= 0.5;
            
            this.hp = baseHp * typeData.hpMult;
            this.maxHp = this.hp;

            let baseSpeed = Math.random() * 0.4 + 0.4 + (wave * 0.02);
            this.speed = baseSpeed * typeData.spdMult;
            this.moveSpeed = this.speed;
            
            this.damage = 1 + wave;
            
            this.skillTimer = 0;
            this.isSummoning = false;
        }

        update() {
            if (this.isSummoning) {
                this.skillTimer++;
                if (this.skillTimer > 60) {
                    this.doSummon();
                    this.isSummoning = false;
                    this.skillTimer = 0;
                }
                return; 
            }

            this.moveSpeed = this.speed * globalBuffs.enemySpeedMult;
            
            if (this.ability === 'stun') {
                this.skillTimer++;
                if (this.skillTimer > 600) {
                    this.isSummoning = true;
                    this.skillTimer = 0;
                    spawnFloatingText("Summon!", this.x + 50, this.y, '#ffffff', 20);
                }
            } 
            else if (this.ability === 'explode') {
            }

            for (let d of defenders) {
                if (d.y === this.y && this.x < d.x + 80 && this.x > d.x) {
                    this.moveSpeed = 0; 
                    // ğŸ”¥ ì  ê³µê²© ë¹ˆë„ 40% (5í”„ë ˆì„ ì¤‘ 2ë²ˆ ê³µê²©)
                    if (frame % 5 < 2) {
                        d.hp -= this.damage;
                    }
                    
                    if (d.hp <= 0) { defenders = defenders.filter(u => u !== d); closeUpgradePanel(); }
                }
            }
            this.x -= this.moveSpeed;
        }

        doSummon() {
            const currentGridX = Math.floor(this.x / CELL_SIZE) * CELL_SIZE;
            const currentGridY = this.y;

            const offsets = [
                { x: -CELL_SIZE, y: 0 },
                { x: 0, y: -CELL_SIZE },
                { x: 0, y: CELL_SIZE }
            ];

            offsets.forEach(offset => {
                const sx = currentGridX + offset.x;
                const sy = currentGridY + offset.y;

                if (sy >= 0 && sy < GAME_HEIGHT && sx > 0) {
                    enemies.push(new Enemy(sx, sy, 'normal'));
                    spawnParticles(sx + 50, sy + 50, 10, '#e74c3c');
                }
            });
        }
        
        takeDamage(amount, isCrit) { 
            if (this.ability === 'dodge' && Math.random() < 0.3) {
                spawnFloatingText("Miss", this.x+50, this.y, '#ccc', 14);
                return;
            }
            if (this.ability === 'armor') {
                amount = Math.max(1, amount - 10);
                if (Math.random() < 0.3) spawnFloatingText("Block", this.x+50, this.y-20, '#888', 12);
            }
            this.hp -= amount; 
            spawnFloatingText(Math.floor(amount), this.x+50, this.y, isCrit ? '#ff00ff' : '#ff4444', isCrit ? 24 : 18); 
        }
        
        draw() {
            ctx.fillStyle = this.color; 
            ctx.beginPath(); ctx.arc(this.x+50, this.y+50, this.radius, 0, Math.PI*2); ctx.fill();
            
            if (this.isSummoning) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x+50, this.y+50, this.radius + 10, 0, Math.PI*2);
                ctx.stroke();
            }

            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x+35, this.y+45, 8, 0, Math.PI*2); ctx.arc(this.x+65, this.y+45, 8, 0, Math.PI*2); ctx.fill();
            
            let hpY = (this.y < 10) ? this.y + 85 : this.y - 15;

            ctx.fillStyle = '#000'; ctx.fillRect(this.x+20, hpY, 60, 5);
            ctx.fillStyle = this.color; ctx.fillRect(this.x+20, hpY, 60*(this.hp/this.maxHp), 5);
            
            if (globalBuffs.enemySpeedMult < 1.0) {
                 ctx.fillStyle = '#00e5ff'; ctx.font = '12px Arial'; ctx.fillText('â„ï¸', this.x+50, this.y+80);
            }
        }
    }

    class Projectile {
        constructor(x, y, dmg, dy, color, isCrit) { 
            this.x = x; this.y = y; this.dmg = dmg; this.dy = dy; this.color = color; 
            this.speed = 10; this.isCrit = isCrit;
        }
        update() { this.x += this.speed; this.y += this.dy * this.speed; }
        draw() { 
            ctx.fillStyle = this.isCrit ? '#fff' : this.color; 
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, this.isCrit ? 10 : 8, 0, Math.PI*2); 
            ctx.fill(); 
            if(this.isCrit) {
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.stroke();
            }
        }
    }

    class FloatingText {
        constructor(text, x, y, color='#fff', size=18) { 
            this.text = text; this.x = x; this.y = y; this.color = color; this.size = size;
            this.life = 1.0; 
            this.dy = -0.5; // ğŸš€ ìˆ˜ì •: ì²œì²œíˆ ì˜¬ë¼ê° (ê¸°ì¡´ -1)
        }
        update() { 
            this.y += this.dy; 
            this.life -= 0.008; // ğŸš€ ìˆ˜ì •: ì•½ 2ì´ˆê°„ ì§€ì† (ê¸°ì¡´ 0.03 -> 0.008)
        }
        draw() { 
            ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; 
            ctx.font = `bold ${this.size}px Arial`; ctx.textAlign='center'; 
            ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0; 
        }
    }
    function spawnFloatingText(text, x, y, color, size) { floatingTexts.push(new FloatingText(text, x, y, color, size)); }

    class Particle {
        constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.vx = (Math.random()-0.5)*5; this.vy = (Math.random()-0.5)*5; this.life = 1.0; }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
    }
    function spawnParticles(x, y, c, color) { for(let i=0; i<c; i++) particles.push(new Particle(x, y, color)); }

    function spawnShockwave(x, y) {
        let wave = new Particle(x, y, '#ffaa00');
        wave.life = 2.0; 
        wave.draw = function() {
            ctx.globalAlpha = Math.max(0, this.life/2);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 330 * (1 - this.life/2), 0, Math.PI*2); 
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
        particles.push(wave);
    }

    function animate() {
        if (!isPlaying) return;
        requestAnimationFrame(animate);
        if (isPaused) return;

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        for (let r=0; r<ROWS; r++) {
            for (let c=0; c<COLS; c++) {
                ctx.fillStyle = (r+c)%2===0 ? '#222' : '#2a2a2a'; ctx.fillRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }
        if (selectedType) { ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3; ctx.strokeRect(0, 0, GAME_WIDTH-CELL_SIZE, GAME_HEIGHT); }
        if (focusedUnit) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.strokeRect(focusedUnit.x, focusedUnit.y, CELL_SIZE, CELL_SIZE); }

        if (enemiesSpawned < enemiesToSpawn) {
            let spawnRate = Math.max(60, 300 - (wave * 30)); 
            if (frame % spawnRate === 0) { enemies.push(new Enemy()); enemiesSpawned++; }
        }

        defenders.forEach(d => d.update());
        defenders.sort((a,b) => a.y - b.y);
        defenders.forEach(d => d.draw());

        enemies.forEach((e, i) => {
            e.update(); e.draw();
            if (e.x < 0) {
                enemies.splice(i, 1);
                lives--;
                updateUI();
                spawnFloatingText("ğŸ’”", 50, e.y, '#ff0000', 40);
                enemiesKilled++; 
                checkWaveClear();

                if (lives <= 0) {
                    isPlaying = false;
                    document.querySelector('#overlay h1').innerText = "GAME OVER";
                    document.querySelector('#overlay-msg').innerText = "ì ìˆ˜ë¥¼ ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
                    document.getElementById('overlay').style.display = 'flex';
                    document.getElementById('start-btn').style.display = 'none'; 
                    document.getElementById('rank-info').style.display = 'block';
                    document.getElementById('new-record-form').style.display = 'none'; 
                    
                    document.getElementById('res-score').innerText = Math.floor(score);

                    if(window.saveScoreAndCheckRank) {
                        window.saveScoreAndCheckRank(Math.floor(score)).then(res => {
                            document.getElementById('res-rank').innerText = `${res.rank}ìœ„`;
                            document.getElementById('res-top-score').innerText = res.topScore;
                            document.getElementById('res-top-name').innerText = res.topName;
                            
                            document.querySelector('#overlay-msg').innerText = "ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!";
                            document.getElementById('start-btn').innerText = "ë‹¤ì‹œ í•˜ê¸°";
                            document.getElementById('start-btn').style.display = 'block';

                            window.currentDocId = res.docId;
                            if (res.isNewRecord) {
                                document.getElementById('new-record-form').style.display = 'block';
                            }
                        });
                    }
                }
            } else if (e.hp <= 0) {
                if (e.ability === 'explode') {
                    spawnShockwave(e.x + 50, e.y + 50); 
                    defenders.forEach(d => {
                        const dist = Math.hypot((d.x+50)-(e.x+50), (d.y+50)-(e.y+50));
                        if (dist < 330) {
                            d.hp -= 10; 
                            spawnFloatingText("-10", d.x+50, d.y, '#ff4400', 20);
                            if (d.hp <= 0) { 
                                defenders = defenders.filter(u => u !== d); 
                                closeUpgradePanel(); 
                            }
                        }
                    });
                }

                enemies.splice(i, 1); 
                let gain = 10 + globalBuffs.goldPerKill;
                energy += gain; 
                score += gain; 
                enemiesKilled++; updateUI();
                spawnParticles(e.x+50, e.y+50, 10, '#e74c3c');
                checkWaveClear();
            }
        });
        projectiles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.x > GAME_WIDTH || p.y < 0 || p.y > GAME_HEIGHT) { projectiles.splice(i, 1); return; }
            for (let e of enemies) {
                if (Math.hypot((e.x+50)-p.x, (e.y+50)-p.y) < (40 + e.radius - 35)) {
                    e.takeDamage(p.dmg, p.isCrit); 
                    spawnParticles(p.x, p.y, 3, p.color); projectiles.splice(i, 1); break;
                }
            }
        });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });
        floatingTexts.forEach((t, i) => { t.update(); t.draw(); if (t.life <= 0) floatingTexts.splice(i, 1); });

        frame++;
    }
</script>
</body>
</html>
